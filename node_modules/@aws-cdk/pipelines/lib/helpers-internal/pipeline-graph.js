"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineGraph = void 0;
const blueprint_1 = require("../blueprint");
const graph_1 = require("./graph");
const pipeline_queries_1 = require("./pipeline-queries");
/**
 * Logic to turn the deployment blueprint into a graph
 *
 * This code makes all the decisions on how to lay out the CodePipeline
 */
class PipelineGraph {
    constructor(pipeline, props = {}) {
        var _a, _b, _c, _d, _e, _f;
        this.pipeline = pipeline;
        this.graph = graph_1.Graph.of('', { type: 'group' });
        this.added = new Map();
        this.assetNodes = new Map();
        this.assetNodesByType = new Map();
        this.stackOutputDependencies = new graph_1.DependencyBuilders();
        this._fileAssetCtr = 0;
        this._dockerAssetCtr = 0;
        this.publishTemplate = (_a = props.publishTemplate) !== null && _a !== void 0 ? _a : false;
        this.prepareStep = (_b = props.prepareStep) !== null && _b !== void 0 ? _b : true;
        this.singlePublisher = (_c = props.singlePublisherPerAssetType) !== null && _c !== void 0 ? _c : false;
        this.queries = new pipeline_queries_1.PipelineQueries(pipeline);
        if (pipeline.synth instanceof blueprint_1.Step) {
            this.synthNode = this.addBuildStep(pipeline.synth);
            if (((_e = (_d = this.synthNode) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.type) === 'step') {
                this.synthNode.data.isBuildStep = true;
            }
        }
        this.lastPreparationNode = this.synthNode;
        const cloudAssembly = (_f = pipeline.synth.primaryOutput) === null || _f === void 0 ? void 0 : _f.primaryOutput;
        if (!cloudAssembly) {
            throw new Error(`The synth step must produce the cloud assembly artifact, but doesn't: ${pipeline.synth}`);
        }
        this.cloudAssemblyFileSet = cloudAssembly;
        if (props.selfMutation) {
            const stage = graph_1.Graph.of('UpdatePipeline', { type: 'group' });
            this.graph.add(stage);
            this.selfMutateNode = graph_1.GraphNode.of('SelfMutate', { type: 'self-update' });
            stage.add(this.selfMutateNode);
            this.selfMutateNode.dependOn(this.synthNode);
            this.lastPreparationNode = this.selfMutateNode;
        }
        const waves = pipeline.waves.map(w => this.addWave(w));
        // Make sure the waves deploy sequentially
        for (let i = 1; i < waves.length; i++) {
            waves[i].dependOn(waves[i - 1]);
        }
        // Add additional dependencies between steps that depend on stack outputs and the stacks
        // that produce them.
    }
    isSynthNode(node) {
        return this.synthNode === node;
    }
    addBuildStep(step) {
        return this.addAndRecurse(step, this.topLevelGraph('Build'));
    }
    addWave(wave) {
        // If the wave only has one Stage in it, don't add an additional Graph around it
        const retGraph = wave.stages.length === 1
            ? this.addStage(wave.stages[0])
            : graph_1.Graph.of(wave.id, { type: 'group' }, wave.stages.map(s => this.addStage(s)));
        this.addPrePost(wave.pre, wave.post, retGraph);
        retGraph.dependOn(this.lastPreparationNode);
        this.graph.add(retGraph);
        return retGraph;
    }
    addStage(stage) {
        const retGraph = graph_1.Graph.of(stage.stageName, { type: 'group' });
        const stackGraphs = new Map();
        for (const stack of stage.stacks) {
            const stackGraph = graph_1.Graph.of(this.simpleStackName(stack.stackName, stage.stageName), { type: 'stack-group', stack });
            const prepareNode = this.prepareStep ? graph_1.GraphNode.of('Prepare', { type: 'prepare', stack }) : undefined;
            const deployNode = graph_1.GraphNode.of('Deploy', {
                type: 'execute',
                stack,
                captureOutputs: this.queries.stackOutputsReferenced(stack).length > 0,
            });
            retGraph.add(stackGraph);
            stackGraph.add(deployNode);
            let firstDeployNode;
            if (prepareNode) {
                stackGraph.add(prepareNode);
                deployNode.dependOn(prepareNode);
                firstDeployNode = prepareNode;
            }
            else {
                firstDeployNode = deployNode;
            }
            stackGraphs.set(stack, stackGraph);
            const cloudAssembly = this.cloudAssemblyFileSet;
            firstDeployNode.dependOn(this.addAndRecurse(cloudAssembly.producer, retGraph));
            // add the template asset
            if (this.publishTemplate) {
                if (!stack.templateAsset) {
                    throw new Error(`"publishTemplate" is enabled, but stack ${stack.stackArtifactId} does not have a template asset`);
                }
                firstDeployNode.dependOn(this.publishAsset(stack.templateAsset));
            }
            // Depend on Assets
            // FIXME: Custom Cloud Assembly currently doesn't actually help separating
            // out templates from assets!!!
            for (const asset of stack.assets) {
                const assetNode = this.publishAsset(asset);
                firstDeployNode.dependOn(assetNode);
            }
            // Add stack output synchronization point
            if (this.queries.stackOutputsReferenced(stack).length > 0) {
                this.stackOutputDependencies.get(stack).dependOn(deployNode);
            }
        }
        for (const stack of stage.stacks) {
            for (const dep of stack.stackDependencies) {
                const stackNode = stackGraphs.get(stack);
                const depNode = stackGraphs.get(dep);
                if (!stackNode) {
                    throw new Error(`cannot find node for ${stack.stackName}`);
                }
                if (!depNode) {
                    throw new Error(`cannot find node for ${dep.stackName}`);
                }
                stackNode.dependOn(depNode);
            }
        }
        this.addPrePost(stage.pre, stage.post, retGraph);
        return retGraph;
    }
    addPrePost(pre, post, parent) {
        const currentNodes = new graph_1.GraphNodeCollection(parent.nodes);
        for (const p of pre) {
            const preNode = this.addAndRecurse(p, parent);
            currentNodes.dependOn(preNode);
        }
        for (const p of post) {
            const postNode = this.addAndRecurse(p, parent);
            postNode === null || postNode === void 0 ? void 0 : postNode.dependOn(...currentNodes.nodes);
        }
    }
    topLevelGraph(name) {
        let ret = this.graph.tryGetChild(name);
        if (!ret) {
            ret = new graph_1.Graph(name);
            this.graph.add(ret);
        }
        return ret;
    }
    addAndRecurse(step, parent) {
        if (step === PipelineGraph.NO_STEP) {
            return undefined;
        }
        const previous = this.added.get(step);
        if (previous) {
            return previous;
        }
        const node = graph_1.GraphNode.of(step.id, { type: 'step', step });
        // If the step is a source step, change the parent to a special "Source" stage
        // (CodePipeline wants it that way)
        if (step.isSource) {
            parent = this.topLevelGraph('Source');
        }
        parent.add(node);
        this.added.set(step, node);
        for (const dep of step.dependencies) {
            const producerNode = this.addAndRecurse(dep, parent);
            node.dependOn(producerNode);
        }
        // Add stack dependencies (by use of the dependency builder this also works
        // if we encounter the Step before the Stack has been properly added yet)
        if (step instanceof blueprint_1.ShellStep) {
            for (const output of Object.values(step.envFromCfnOutputs)) {
                const stack = this.queries.producingStack(output);
                this.stackOutputDependencies.get(stack).dependBy(node);
            }
        }
        return node;
    }
    publishAsset(stackAsset) {
        const assetsGraph = this.topLevelGraph('Assets');
        let assetNode = this.assetNodes.get(stackAsset.assetId);
        if (assetNode) {
            // If there's already a node publishing this asset, add as a new publishing
            // destination to the same node.
        }
        else if (this.singlePublisher && this.assetNodesByType.has(stackAsset.assetType)) {
            // If we're doing a single node per type, lookup by that
            assetNode = this.assetNodesByType.get(stackAsset.assetType);
        }
        else {
            // Otherwise add a new one
            const id = stackAsset.assetType === blueprint_1.AssetType.FILE
                ? (this.singlePublisher ? 'FileAsset' : `FileAsset${++this._fileAssetCtr}`)
                : (this.singlePublisher ? 'DockerAsset' : `DockerAsset${++this._dockerAssetCtr}`);
            assetNode = graph_1.GraphNode.of(id, { type: 'publish-assets', assets: [] });
            assetsGraph.add(assetNode);
            assetNode.dependOn(this.lastPreparationNode);
            this.assetNodesByType.set(stackAsset.assetType, assetNode);
            this.assetNodes.set(stackAsset.assetId, assetNode);
        }
        const data = assetNode.data;
        if ((data === null || data === void 0 ? void 0 : data.type) !== 'publish-assets') {
            throw new Error(`${assetNode} has the wrong data.type: ${data === null || data === void 0 ? void 0 : data.type}`);
        }
        if (!data.assets.some(a => a.assetSelector === stackAsset.assetSelector)) {
            data.assets.push(stackAsset);
        }
        return assetNode;
    }
    /**
     * Simplify the stack name by removing the `Stage-` prefix if it exists.
     */
    simpleStackName(stackName, stageName) {
        return stripPrefix(stackName, `${stageName}-`);
    }
}
exports.PipelineGraph = PipelineGraph;
/**
 * A Step object that may be used as the producer of FileSets that should not be represented in the graph
 */
PipelineGraph.NO_STEP = new class extends blueprint_1.Step {
}('NO_STEP');
function stripPrefix(s, prefix) {
    return s.startsWith(prefix) ? s.substr(prefix.length) : s;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlwZWxpbmUtZ3JhcGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwaXBlbGluZS1ncmFwaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw0Q0FBdUg7QUFFdkgsbUNBQW9GO0FBQ3BGLHlEQUFxRDtBQWlDckQ7Ozs7R0FJRztBQUNILE1BQWEsYUFBYTtJQXdCeEIsWUFBNEIsUUFBc0IsRUFBRSxRQUE0QixFQUFFOztRQUF0RCxhQUFRLEdBQVIsUUFBUSxDQUFjO1FBbEJsQyxVQUFLLEdBQVcsYUFBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUkvQyxVQUFLLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFDcEMsZUFBVSxHQUFHLElBQUksR0FBRyxFQUFzQixDQUFDO1FBQzNDLHFCQUFnQixHQUFHLElBQUksR0FBRyxFQUF5QixDQUFDO1FBR3BELDRCQUF1QixHQUFHLElBQUksMEJBQWtCLEVBQXdCLENBQUM7UUFNbEYsa0JBQWEsR0FBRyxDQUFDLENBQUM7UUFDbEIsb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFHMUIsSUFBSSxDQUFDLGVBQWUsU0FBRyxLQUFLLENBQUMsZUFBZSxtQ0FBSSxLQUFLLENBQUM7UUFDdEQsSUFBSSxDQUFDLFdBQVcsU0FBRyxLQUFLLENBQUMsV0FBVyxtQ0FBSSxJQUFJLENBQUM7UUFDN0MsSUFBSSxDQUFDLGVBQWUsU0FBRyxLQUFLLENBQUMsMkJBQTJCLG1DQUFJLEtBQUssQ0FBQztRQUVsRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksa0NBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU3QyxJQUFJLFFBQVEsQ0FBQyxLQUFLLFlBQVksZ0JBQUksRUFBRTtZQUNsQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25ELElBQUksYUFBQSxJQUFJLENB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eEUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDOUI7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxlQUFlLENBQUMsU0FBaUIsRUFBRSxTQUFpQjtRQUMxRCxPQUFPLFdBQVcsQ0FBQyxTQUFTLEVBQUUsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELENBQUM7O0FBalFILHNDQWtRQztBQWpRQzs7R0FFRztBQUNvQixxQkFBTyxHQUFTLElBQUksS0FBTSxTQUFRLGdCQUFJO0NBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQStRL0UsU0FBUyxXQUFXLENBQUMsQ0FBUyxFQUFFLE1BQWM7SUFDNUMsT0FBTyxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBc3NldFR5cGUsIEZpbGVTZXQsIFNoZWxsU3RlcCwgU3RhY2tBc3NldCwgU3RhY2tEZXBsb3ltZW50LCBTdGFnZURlcGxveW1lbnQsIFN0ZXAsIFdhdmUgfSBmcm9tICcuLi9ibHVlcHJpbnQnO1xuaW1wb3J0IHsgUGlwZWxpbmVCYXNlIH0gZnJvbSAnLi4vbWFpbi9waXBlbGluZS1iYXNlJztcbmltcG9ydCB7IERlcGVuZGVuY3lCdWlsZGVycywgR3JhcGgsIEdyYXBoTm9kZSwgR3JhcGhOb2RlQ29sbGVjdGlvbiB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgUGlwZWxpbmVRdWVyaWVzIH0gZnJvbSAnLi9waXBlbGluZS1xdWVyaWVzJztcblxuZXhwb3J0IGludGVyZmFjZSBQaXBlbGluZUdyYXBoUHJvcHMge1xuICAvKipcbiAgICogQWRkIGEgc2VsZi1tdXRhdGlvbiBzdGVwLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2VsZk11dGF0aW9uPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUHVibGlzaGVzIHRoZSB0ZW1wbGF0ZSBhc3NldCB0byBTMy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHB1Ymxpc2hUZW1wbGF0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gY29tYmluZSBhc3NldCBwdWJsaXNoZXJzIGZvciB0aGUgc2FtZSB0eXBlIGludG8gb25lIHN0ZXBcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHNpbmdsZVB1Ymxpc2hlclBlckFzc2V0VHlwZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEFkZCBhIFwicHJlcGFyZVwiIHN0ZXAgZm9yIGVhY2ggc3RhY2sgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBjaGFuZ2VcbiAgICogc2V0LiBJZiB0aGlzIGlzIGRpc2FibGVkLCBvbmx5IHRoZSBcImV4ZWN1dGVcIiBzdGVwIHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHByZXBhcmVTdGVwPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBMb2dpYyB0byB0dXJuIHRoZSBkZXBsb3ltZW50IGJsdWVwcmludCBpbnRvIGEgZ3JhcGhcbiAqXG4gKiBUaGlzIGNvZGUgbWFrZXMgYWxsIHRoZSBkZWNpc2lvbnMgb24gaG93IHRvIGxheSBvdXQgdGhlIENvZGVQaXBlbGluZVxuICovXG5leHBvcnQgY2xhc3MgUGlwZWxpbmVHcmFwaCB7XG4gIC8qKlxuICAgKiBBIFN0ZXAgb2JqZWN0IHRoYXQgbWF5IGJlIHVzZWQgYXMgdGhlIHByb2R1Y2VyIG9mIEZpbGVTZXRzIHRoYXQgc2hvdWxkIG5vdCBiZSByZXByZXNlbnRlZCBpbiB0aGUgZ3JhcGhcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTk9fU1RFUDogU3RlcCA9IG5ldyBjbGFzcyBleHRlbmRzIFN0ZXAgeyB9KCdOT19TVEVQJyk7XG5cbiAgcHVibGljIHJlYWRvbmx5IGdyYXBoOiBBR3JhcGggPSBHcmFwaC5vZignJywgeyB0eXBlOiAnZ3JvdXAnIH0pO1xuICBwdWJsaWMgcmVhZG9ubHkgY2xvdWRBc3NlbWJseUZpbGVTZXQ6IEZpbGVTZXQ7XG4gIHB1YmxpYyByZWFkb25seSBxdWVyaWVzOiBQaXBlbGluZVF1ZXJpZXM7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBhZGRlZCA9IG5ldyBNYXA8U3RlcCwgQUdyYXBoTm9kZT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBhc3NldE5vZGVzID0gbmV3IE1hcDxzdHJpbmcsIEFHcmFwaE5vZGU+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXNzZXROb2Rlc0J5VHlwZSA9IG5ldyBNYXA8QXNzZXRUeXBlLCBBR3JhcGhOb2RlPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IHN5bnRoTm9kZT86IEFHcmFwaE5vZGU7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VsZk11dGF0ZU5vZGU/OiBBR3JhcGhOb2RlO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrT3V0cHV0RGVwZW5kZW5jaWVzID0gbmV3IERlcGVuZGVuY3lCdWlsZGVyczxTdGFja0RlcGxveW1lbnQsIGFueT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBwdWJsaXNoVGVtcGxhdGU6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJlcGFyZVN0ZXA6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgc2luZ2xlUHVibGlzaGVyOiBib29sZWFuO1xuXG4gIHByaXZhdGUgbGFzdFByZXBhcmF0aW9uTm9kZT86IEFHcmFwaE5vZGU7XG4gIHByaXZhdGUgX2ZpbGVBc3NldEN0ciA9IDA7XG4gIHByaXZhdGUgX2RvY2tlckFzc2V0Q3RyID0gMDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgcGlwZWxpbmU6IFBpcGVsaW5lQmFzZSwgcHJvcHM6IFBpcGVsaW5lR3JhcGhQcm9wcyA9IHt9KSB7XG4gICAgdGhpcy5wdWJsaXNoVGVtcGxhdGUgPSBwcm9wcy5wdWJsaXNoVGVtcGxhdGUgPz8gZmFsc2U7XG4gICAgdGhpcy5wcmVwYXJlU3RlcCA9IHByb3BzLnByZXBhcmVTdGVwID8/IHRydWU7XG4gICAgdGhpcy5zaW5nbGVQdWJsaXNoZXIgPSBwcm9wcy5zaW5nbGVQdWJsaXNoZXJQZXJBc3NldFR5cGUgPz8gZmFsc2U7XG5cbiAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgUGlwZWxpbmVRdWVyaWVzKHBpcGVsaW5lKTtcblxuICAgIGlmIChwaXBlbGluZS5zeW50aCBpbnN0YW5jZW9mIFN0ZXApIHtcbiAgICAgIHRoaXMuc3ludGhOb2RlID0gdGhpcy5hZGRCdWlsZFN0ZXAocGlwZWxpbmUuc3ludGgpO1xuICAgICAgaWYgKHRoaXMuc3ludGhOb2RlPy5kYXRhPy50eXBlID09PSAnc3RlcCcpIHtcbiAgICAgICAgdGhpcy5zeW50aE5vZGUuZGF0YS5pc0J1aWxkU3RlcCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdFByZXBhcmF0aW9uTm9kZSA9IHRoaXMuc3ludGhOb2RlO1xuXG4gICAgY29uc3QgY2xvdWRBc3NlbWJseSA9IHBpcGVsaW5lLnN5bnRoLnByaW1hcnlPdXRwdXQ/LnByaW1hcnlPdXRwdXQ7XG4gICAgaWYgKCFjbG91ZEFzc2VtYmx5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzeW50aCBzdGVwIG11c3QgcHJvZHVjZSB0aGUgY2xvdWQgYXNzZW1ibHkgYXJ0aWZhY3QsIGJ1dCBkb2Vzbid0OiAke3BpcGVsaW5lLnN5bnRofWApO1xuICAgIH1cblxuICAgIHRoaXMuY2xvdWRBc3NlbWJseUZpbGVTZXQgPSBjbG91ZEFzc2VtYmx5O1xuXG4gICAgaWYgKHByb3BzLnNlbGZNdXRhdGlvbikge1xuICAgICAgY29uc3Qgc3RhZ2U6IEFHcmFwaCA9IEdyYXBoLm9mKCdVcGRhdGVQaXBlbGluZScsIHsgdHlwZTogJ2dyb3VwJyB9KTtcbiAgICAgIHRoaXMuZ3JhcGguYWRkKHN0YWdlKTtcbiAgICAgIHRoaXMuc2VsZk11dGF0ZU5vZGUgPSBHcmFwaE5vZGUub2YoJ1NlbGZNdXRhdGUnLCB7IHR5cGU6ICdzZWxmLXVwZGF0ZScgfSk7XG4gICAgICBzdGFnZS5hZGQodGhpcy5zZWxmTXV0YXRlTm9kZSk7XG5cbiAgICAgIHRoaXMuc2VsZk11dGF0ZU5vZGUuZGVwZW5kT24odGhpcy5zeW50aE5vZGUpO1xuICAgICAgdGhpcy5sYXN0UHJlcGFyYXRpb25Ob2RlID0gdGhpcy5zZWxmTXV0YXRlTm9kZTtcbiAgICB9XG5cbiAgICBjb25zdCB3YXZlcyA9IHBpcGVsaW5lLndhdmVzLm1hcCh3ID0+IHRoaXMuYWRkV2F2ZSh3KSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIHdhdmVzIGRlcGxveSBzZXF1ZW50aWFsbHlcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3YXZlc1tpXS5kZXBlbmRPbih3YXZlc1tpIC0gMV0pO1xuICAgIH1cblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN0ZXBzIHRoYXQgZGVwZW5kIG9uIHN0YWNrIG91dHB1dHMgYW5kIHRoZSBzdGFja3NcbiAgICAvLyB0aGF0IHByb2R1Y2UgdGhlbS5cbiAgfVxuXG4gIHB1YmxpYyBpc1N5bnRoTm9kZShub2RlOiBBR3JhcGhOb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ludGhOb2RlID09PSBub2RlO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRCdWlsZFN0ZXAoc3RlcDogU3RlcCkge1xuICAgIHJldHVybiB0aGlzLmFkZEFuZFJlY3Vyc2Uoc3RlcCwgdGhpcy50b3BMZXZlbEdyYXBoKCdCdWlsZCcpKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkV2F2ZSh3YXZlOiBXYXZlKTogQUdyYXBoIHtcbiAgICAvLyBJZiB0aGUgd2F2ZSBvbmx5IGhhcyBvbmUgU3RhZ2UgaW4gaXQsIGRvbid0IGFkZCBhbiBhZGRpdGlvbmFsIEdyYXBoIGFyb3VuZCBpdFxuICAgIGNvbnN0IHJldEdyYXBoOiBBR3JhcGggPSB3YXZlLnN0YWdlcy5sZW5ndGggPT09IDFcbiAgICAgID8gdGhpcy5hZGRTdGFnZSh3YXZlLnN0YWdlc1swXSlcbiAgICAgIDogR3JhcGgub2Yod2F2ZS5pZCwgeyB0eXBlOiAnZ3JvdXAnIH0sIHdhdmUuc3RhZ2VzLm1hcChzID0+IHRoaXMuYWRkU3RhZ2UocykpKTtcblxuICAgIHRoaXMuYWRkUHJlUG9zdCh3YXZlLnByZSwgd2F2ZS5wb3N0LCByZXRHcmFwaCk7XG4gICAgcmV0R3JhcGguZGVwZW5kT24odGhpcy5sYXN0UHJlcGFyYXRpb25Ob2RlKTtcbiAgICB0aGlzLmdyYXBoLmFkZChyZXRHcmFwaCk7XG5cbiAgICByZXR1cm4gcmV0R3JhcGg7XG4gIH1cblxuICBwcml2YXRlIGFkZFN0YWdlKHN0YWdlOiBTdGFnZURlcGxveW1lbnQpOiBBR3JhcGgge1xuICAgIGNvbnN0IHJldEdyYXBoOiBBR3JhcGggPSBHcmFwaC5vZihzdGFnZS5zdGFnZU5hbWUsIHsgdHlwZTogJ2dyb3VwJyB9KTtcblxuICAgIGNvbnN0IHN0YWNrR3JhcGhzID0gbmV3IE1hcDxTdGFja0RlcGxveW1lbnQsIEFHcmFwaD4oKTtcblxuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhZ2Uuc3RhY2tzKSB7XG4gICAgICBjb25zdCBzdGFja0dyYXBoOiBBR3JhcGggPSBHcmFwaC5vZih0aGlzLnNpbXBsZVN0YWNrTmFtZShzdGFjay5zdGFja05hbWUsIHN0YWdlLnN0YWdlTmFtZSksIHsgdHlwZTogJ3N0YWNrLWdyb3VwJywgc3RhY2sgfSk7XG4gICAgICBjb25zdCBwcmVwYXJlTm9kZTogQUdyYXBoTm9kZSB8IHVuZGVmaW5lZCA9IHRoaXMucHJlcGFyZVN0ZXAgPyBHcmFwaE5vZGUub2YoJ1ByZXBhcmUnLCB7IHR5cGU6ICdwcmVwYXJlJywgc3RhY2sgfSkgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBkZXBsb3lOb2RlOiBBR3JhcGhOb2RlID0gR3JhcGhOb2RlLm9mKCdEZXBsb3knLCB7XG4gICAgICAgIHR5cGU6ICdleGVjdXRlJyxcbiAgICAgICAgc3RhY2ssXG4gICAgICAgIGNhcHR1cmVPdXRwdXRzOiB0aGlzLnF1ZXJpZXMuc3RhY2tPdXRwdXRzUmVmZXJlbmNlZChzdGFjaykubGVuZ3RoID4gMCxcbiAgICAgIH0pO1xuXG4gICAgICByZXRHcmFwaC5hZGQoc3RhY2tHcmFwaCk7XG5cbiAgICAgIHN0YWNrR3JhcGguYWRkKGRlcGxveU5vZGUpO1xuICAgICAgbGV0IGZpcnN0RGVwbG95Tm9kZTtcbiAgICAgIGlmIChwcmVwYXJlTm9kZSkge1xuICAgICAgICBzdGFja0dyYXBoLmFkZChwcmVwYXJlTm9kZSk7XG4gICAgICAgIGRlcGxveU5vZGUuZGVwZW5kT24ocHJlcGFyZU5vZGUpO1xuICAgICAgICBmaXJzdERlcGxveU5vZGUgPSBwcmVwYXJlTm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RGVwbG95Tm9kZSA9IGRlcGxveU5vZGU7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrR3JhcGhzLnNldChzdGFjaywgc3RhY2tHcmFwaCk7XG5cbiAgICAgIGNvbnN0IGNsb3VkQXNzZW1ibHkgPSB0aGlzLmNsb3VkQXNzZW1ibHlGaWxlU2V0O1xuXG4gICAgICBmaXJzdERlcGxveU5vZGUuZGVwZW5kT24odGhpcy5hZGRBbmRSZWN1cnNlKGNsb3VkQXNzZW1ibHkucHJvZHVjZXIsIHJldEdyYXBoKSk7XG5cbiAgICAgIC8vIGFkZCB0aGUgdGVtcGxhdGUgYXNzZXRcbiAgICAgIGlmICh0aGlzLnB1Ymxpc2hUZW1wbGF0ZSkge1xuICAgICAgICBpZiAoIXN0YWNrLnRlbXBsYXRlQXNzZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwicHVibGlzaFRlbXBsYXRlXCIgaXMgZW5hYmxlZCwgYnV0IHN0YWNrICR7c3RhY2suc3RhY2tBcnRpZmFjdElkfSBkb2VzIG5vdCBoYXZlIGEgdGVtcGxhdGUgYXNzZXRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0RGVwbG95Tm9kZS5kZXBlbmRPbih0aGlzLnB1Ymxpc2hBc3NldChzdGFjay50ZW1wbGF0ZUFzc2V0KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlcGVuZCBvbiBBc3NldHNcbiAgICAgIC8vIEZJWE1FOiBDdXN0b20gQ2xvdWQgQXNzZW1ibHkgY3VycmVudGx5IGRvZXNuJ3QgYWN0dWFsbHkgaGVscCBzZXBhcmF0aW5nXG4gICAgICAvLyBvdXQgdGVtcGxhdGVzIGZyb20gYXNzZXRzISEhXG4gICAgICBmb3IgKGNvbnN0IGFzc2V0IG9mIHN0YWNrLmFzc2V0cykge1xuICAgICAgICBjb25zdCBhc3NldE5vZGUgPSB0aGlzLnB1Ymxpc2hBc3NldChhc3NldCk7XG4gICAgICAgIGZpcnN0RGVwbG95Tm9kZS5kZXBlbmRPbihhc3NldE5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgc3RhY2sgb3V0cHV0IHN5bmNocm9uaXphdGlvbiBwb2ludFxuICAgICAgaWYgKHRoaXMucXVlcmllcy5zdGFja091dHB1dHNSZWZlcmVuY2VkKHN0YWNrKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3RhY2tPdXRwdXREZXBlbmRlbmNpZXMuZ2V0KHN0YWNrKS5kZXBlbmRPbihkZXBsb3lOb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWdlLnN0YWNrcykge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc3RhY2suc3RhY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhY2tOb2RlID0gc3RhY2tHcmFwaHMuZ2V0KHN0YWNrKTtcbiAgICAgICAgY29uc3QgZGVwTm9kZSA9IHN0YWNrR3JhcGhzLmdldChkZXApO1xuICAgICAgICBpZiAoIXN0YWNrTm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGZpbmQgbm9kZSBmb3IgJHtzdGFjay5zdGFja05hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXBOb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZmluZCBub2RlIGZvciAke2RlcC5zdGFja05hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tOb2RlLmRlcGVuZE9uKGRlcE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRkUHJlUG9zdChzdGFnZS5wcmUsIHN0YWdlLnBvc3QsIHJldEdyYXBoKTtcblxuICAgIHJldHVybiByZXRHcmFwaDtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUHJlUG9zdChwcmU6IFN0ZXBbXSwgcG9zdDogU3RlcFtdLCBwYXJlbnQ6IEFHcmFwaCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlcyA9IG5ldyBHcmFwaE5vZGVDb2xsZWN0aW9uKHBhcmVudC5ub2Rlcyk7XG4gICAgZm9yIChjb25zdCBwIG9mIHByZSkge1xuICAgICAgY29uc3QgcHJlTm9kZSA9IHRoaXMuYWRkQW5kUmVjdXJzZShwLCBwYXJlbnQpO1xuICAgICAgY3VycmVudE5vZGVzLmRlcGVuZE9uKHByZU5vZGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHAgb2YgcG9zdCkge1xuICAgICAgY29uc3QgcG9zdE5vZGUgPSB0aGlzLmFkZEFuZFJlY3Vyc2UocCwgcGFyZW50KTtcbiAgICAgIHBvc3ROb2RlPy5kZXBlbmRPbiguLi5jdXJyZW50Tm9kZXMubm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdG9wTGV2ZWxHcmFwaChuYW1lOiBzdHJpbmcpOiBBR3JhcGgge1xuICAgIGxldCByZXQgPSB0aGlzLmdyYXBoLnRyeUdldENoaWxkKG5hbWUpO1xuICAgIGlmICghcmV0KSB7XG4gICAgICByZXQgPSBuZXcgR3JhcGg8R3JhcGhBbm5vdGF0aW9uPihuYW1lKTtcbiAgICAgIHRoaXMuZ3JhcGguYWRkKHJldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQgYXMgQUdyYXBoO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRBbmRSZWN1cnNlKHN0ZXA6IFN0ZXAsIHBhcmVudDogQUdyYXBoKSB7XG4gICAgaWYgKHN0ZXAgPT09IFBpcGVsaW5lR3JhcGguTk9fU1RFUCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuYWRkZWQuZ2V0KHN0ZXApO1xuICAgIGlmIChwcmV2aW91cykgeyByZXR1cm4gcHJldmlvdXM7IH1cblxuICAgIGNvbnN0IG5vZGU6IEFHcmFwaE5vZGUgPSBHcmFwaE5vZGUub2Yoc3RlcC5pZCwgeyB0eXBlOiAnc3RlcCcsIHN0ZXAgfSk7XG5cbiAgICAvLyBJZiB0aGUgc3RlcCBpcyBhIHNvdXJjZSBzdGVwLCBjaGFuZ2UgdGhlIHBhcmVudCB0byBhIHNwZWNpYWwgXCJTb3VyY2VcIiBzdGFnZVxuICAgIC8vIChDb2RlUGlwZWxpbmUgd2FudHMgaXQgdGhhdCB3YXkpXG4gICAgaWYgKHN0ZXAuaXNTb3VyY2UpIHtcbiAgICAgIHBhcmVudCA9IHRoaXMudG9wTGV2ZWxHcmFwaCgnU291cmNlJyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFkZChub2RlKTtcbiAgICB0aGlzLmFkZGVkLnNldChzdGVwLCBub2RlKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIHN0ZXAuZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBwcm9kdWNlck5vZGUgPSB0aGlzLmFkZEFuZFJlY3Vyc2UoZGVwLCBwYXJlbnQpO1xuICAgICAgbm9kZS5kZXBlbmRPbihwcm9kdWNlck5vZGUpO1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGFjayBkZXBlbmRlbmNpZXMgKGJ5IHVzZSBvZiB0aGUgZGVwZW5kZW5jeSBidWlsZGVyIHRoaXMgYWxzbyB3b3Jrc1xuICAgIC8vIGlmIHdlIGVuY291bnRlciB0aGUgU3RlcCBiZWZvcmUgdGhlIFN0YWNrIGhhcyBiZWVuIHByb3Blcmx5IGFkZGVkIHlldClcbiAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIFNoZWxsU3RlcCkge1xuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2YgT2JqZWN0LnZhbHVlcyhzdGVwLmVudkZyb21DZm5PdXRwdXRzKSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMucXVlcmllcy5wcm9kdWNpbmdTdGFjayhvdXRwdXQpO1xuICAgICAgICB0aGlzLnN0YWNrT3V0cHV0RGVwZW5kZW5jaWVzLmdldChzdGFjaykuZGVwZW5kQnkobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwcml2YXRlIHB1Ymxpc2hBc3NldChzdGFja0Fzc2V0OiBTdGFja0Fzc2V0KTogQUdyYXBoTm9kZSB7XG4gICAgY29uc3QgYXNzZXRzR3JhcGggPSB0aGlzLnRvcExldmVsR3JhcGgoJ0Fzc2V0cycpO1xuXG4gICAgbGV0IGFzc2V0Tm9kZSA9IHRoaXMuYXNzZXROb2Rlcy5nZXQoc3RhY2tBc3NldC5hc3NldElkKTtcbiAgICBpZiAoYXNzZXROb2RlKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSBub2RlIHB1Ymxpc2hpbmcgdGhpcyBhc3NldCwgYWRkIGFzIGEgbmV3IHB1Ymxpc2hpbmdcbiAgICAgIC8vIGRlc3RpbmF0aW9uIHRvIHRoZSBzYW1lIG5vZGUuXG4gICAgfSBlbHNlIGlmICh0aGlzLnNpbmdsZVB1Ymxpc2hlciAmJiB0aGlzLmFzc2V0Tm9kZXNCeVR5cGUuaGFzKHN0YWNrQXNzZXQuYXNzZXRUeXBlKSkge1xuICAgICAgLy8gSWYgd2UncmUgZG9pbmcgYSBzaW5nbGUgbm9kZSBwZXIgdHlwZSwgbG9va3VwIGJ5IHRoYXRcbiAgICAgIGFzc2V0Tm9kZSA9IHRoaXMuYXNzZXROb2Rlc0J5VHlwZS5nZXQoc3RhY2tBc3NldC5hc3NldFR5cGUpITtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyBvbmVcbiAgICAgIGNvbnN0IGlkID0gc3RhY2tBc3NldC5hc3NldFR5cGUgPT09IEFzc2V0VHlwZS5GSUxFXG4gICAgICAgID8gKHRoaXMuc2luZ2xlUHVibGlzaGVyID8gJ0ZpbGVBc3NldCcgOiBgRmlsZUFzc2V0JHsrK3RoaXMuX2ZpbGVBc3NldEN0cn1gKVxuICAgICAgICA6ICh0aGlzLnNpbmdsZVB1Ymxpc2hlciA/ICdEb2NrZXJBc3NldCcgOiBgRG9ja2VyQXNzZXQkeysrdGhpcy5fZG9ja2VyQXNzZXRDdHJ9YCk7XG5cbiAgICAgIGFzc2V0Tm9kZSA9IEdyYXBoTm9kZS5vZihpZCwgeyB0eXBlOiAncHVibGlzaC1hc3NldHMnLCBhc3NldHM6IFtdIH0pO1xuICAgICAgYXNzZXRzR3JhcGguYWRkKGFzc2V0Tm9kZSk7XG4gICAgICBhc3NldE5vZGUuZGVwZW5kT24odGhpcy5sYXN0UHJlcGFyYXRpb25Ob2RlKTtcblxuICAgICAgdGhpcy5hc3NldE5vZGVzQnlUeXBlLnNldChzdGFja0Fzc2V0LmFzc2V0VHlwZSwgYXNzZXROb2RlKTtcbiAgICAgIHRoaXMuYXNzZXROb2Rlcy5zZXQoc3RhY2tBc3NldC5hc3NldElkLCBhc3NldE5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhc3NldE5vZGUuZGF0YTtcbiAgICBpZiAoZGF0YT8udHlwZSAhPT0gJ3B1Ymxpc2gtYXNzZXRzJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Fzc2V0Tm9kZX0gaGFzIHRoZSB3cm9uZyBkYXRhLnR5cGU6ICR7ZGF0YT8udHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLmFzc2V0cy5zb21lKGEgPT4gYS5hc3NldFNlbGVjdG9yID09PSBzdGFja0Fzc2V0LmFzc2V0U2VsZWN0b3IpKSB7XG4gICAgICBkYXRhLmFzc2V0cy5wdXNoKHN0YWNrQXNzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NldE5vZGU7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxpZnkgdGhlIHN0YWNrIG5hbWUgYnkgcmVtb3ZpbmcgdGhlIGBTdGFnZS1gIHByZWZpeCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBwcml2YXRlIHNpbXBsZVN0YWNrTmFtZShzdGFja05hbWU6IHN0cmluZywgc3RhZ2VOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaXBQcmVmaXgoc3RhY2tOYW1lLCBgJHtzdGFnZU5hbWV9LWApO1xuICB9XG59XG5cbnR5cGUgR3JhcGhBbm5vdGF0aW9uID1cbiAgeyByZWFkb25seSB0eXBlOiAnZ3JvdXAnIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdzdGFjay1ncm91cCc7IHJlYWRvbmx5IHN0YWNrOiBTdGFja0RlcGxveW1lbnQgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ3B1Ymxpc2gtYXNzZXRzJzsgcmVhZG9ubHkgYXNzZXRzOiBTdGFja0Fzc2V0W10gfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ3N0ZXAnOyByZWFkb25seSBzdGVwOiBTdGVwOyBpc0J1aWxkU3RlcD86IGJvb2xlYW4gfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ3NlbGYtdXBkYXRlJyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAncHJlcGFyZSc7IHJlYWRvbmx5IHN0YWNrOiBTdGFja0RlcGxveW1lbnQgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2V4ZWN1dGUnOyByZWFkb25seSBzdGFjazogU3RhY2tEZXBsb3ltZW50OyByZWFkb25seSBjYXB0dXJlT3V0cHV0czogYm9vbGVhbiB9XG4gIDtcblxuLy8gVHlwZSBhbGlhc2VzIGZvciB0aGUgZ3JhcGggbm9kZXMgdGFnZ2VkIHdpdGggb3VyIHNwZWNpZmljIGFubm90YXRpb24gdHlwZVxuLy8gKHRvIHNhdmUgb24gZ2VuZXJpY3MgaW4gdGhlIGNvZGUgYWJvdmUpLlxuZXhwb3J0IHR5cGUgQUdyYXBoTm9kZSA9IEdyYXBoTm9kZTxHcmFwaEFubm90YXRpb24+O1xuZXhwb3J0IHR5cGUgQUdyYXBoID0gR3JhcGg8R3JhcGhBbm5vdGF0aW9uPjtcblxuZnVuY3Rpb24gc3RyaXBQcmVmaXgoczogc3RyaW5nLCBwcmVmaXg6IHN0cmluZykge1xuICByZXR1cm4gcy5zdGFydHNXaXRoKHByZWZpeCkgPyBzLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHM7XG59Il19