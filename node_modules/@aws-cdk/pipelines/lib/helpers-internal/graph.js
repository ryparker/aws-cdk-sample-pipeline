"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isGraph = exports.GraphNodeCollection = exports.Graph = exports.DependencyBuilders = exports.DependencyBuilder = exports.GraphNode = void 0;
/**
 * A library for nested graphs
 */
const javascript_1 = require("../private/javascript");
const toposort_1 = require("./toposort");
class GraphNode {
    constructor(id, props = {}) {
        this.id = id;
        this.dependencies = [];
        this.data = props.data;
    }
    static of(id, data) {
        return new GraphNode(id, { data });
    }
    /**
     * A graph-wide unique identifier for this node. Rendered by joining the IDs
     * of all ancestors with hyphens.
     */
    get uniqueId() {
        return this.ancestorPath(this.root).map(x => x.id).join('-');
    }
    /**
     * The union of all dependencies of this node and the dependencies of all
     * parent graphs.
     */
    get allDeps() {
        var _a, _b;
        const fromParent = (_b = (_a = this.parentGraph) === null || _a === void 0 ? void 0 : _a.allDeps) !== null && _b !== void 0 ? _b : [];
        return [...this.dependencies, ...fromParent];
    }
    dependOn(...dependencies) {
        if (dependencies.includes(this)) {
            throw new Error(`Cannot add dependency on self: ${this}`);
        }
        this.dependencies.push(...dependencies.filter(javascript_1.isDefined));
    }
    ancestorPath(upTo) {
        let x = this;
        const ret = [x];
        while (x.parentGraph && x.parentGraph !== upTo) {
            x = x.parentGraph;
            ret.unshift(x);
        }
        return ret;
    }
    rootPath() {
        let x = this;
        const ret = [x];
        while (x.parentGraph) {
            x = x.parentGraph;
            ret.unshift(x);
        }
        return ret;
    }
    get root() {
        let x = this;
        while (x.parentGraph) {
            x = x.parentGraph;
        }
        return x;
    }
    get parentGraph() {
        return this._parentGraph;
    }
    /**
     * @internal
     */
    _setParentGraph(parentGraph) {
        if (this._parentGraph) {
            throw new Error('Node already has a parent');
        }
        this._parentGraph = parentGraph;
    }
    toString() {
        return `${this.constructor.name}(${this.id})`;
    }
}
exports.GraphNode = GraphNode;
/**
 * A dependency set that can be constructed partially and later finished
 *
 * It doesn't matter in what order sources and targets for the dependency
 * relationship(s) get added. This class can serve as a synchronization
 * point if the order in which graph nodes get added to the graph is not
 * well-defined.
 *
 * Useful utility during graph building.
 */
class DependencyBuilder {
    constructor() {
        this.targets = [];
        this.sources = [];
    }
    dependOn(...targets) {
        for (const target of targets) {
            for (const source of this.sources) {
                source.dependOn(target);
            }
            this.targets.push(target);
        }
        return this;
    }
    dependBy(...sources) {
        for (const source of sources) {
            for (const target of this.targets) {
                source.dependOn(target);
            }
            this.sources.push(source);
        }
        return this;
    }
}
exports.DependencyBuilder = DependencyBuilder;
class DependencyBuilders {
    constructor() {
        this.builders = new Map();
    }
    get(key) {
        const b = this.builders.get(key);
        if (b) {
            return b;
        }
        const ret = new DependencyBuilder();
        this.builders.set(key, ret);
        return ret;
    }
}
exports.DependencyBuilders = DependencyBuilders;
class Graph extends GraphNode {
    constructor(name, props = {}) {
        super(name, props);
        this.children = new Map();
        if (props.nodes) {
            this.add(...props.nodes);
        }
    }
    static of(id, data, nodes) {
        return new Graph(id, { data, nodes });
    }
    get nodes() {
        return new Set(this.children.values());
    }
    tryGetChild(name) {
        return this.children.get(name);
    }
    contains(node) {
        return this.nodes.has(node);
    }
    add(...nodes) {
        for (const node of nodes) {
            node._setParentGraph(this);
            if (this.children.has(node.id)) {
                throw new Error(`Node with duplicate id: ${node.id}`);
            }
            this.children.set(node.id, node);
        }
    }
    absorb(other) {
        this.add(...other.nodes);
    }
    /**
     * Return topologically sorted tranches of nodes at this graph level
     */
    sortedChildren() {
        // Project dependencies to current children
        const nodes = this.nodes;
        const projectedDependencies = projectDependencies(this.deepDependencies(), (node) => {
            while (!nodes.has(node) && node.parentGraph) {
                node = node.parentGraph;
            }
            return nodes.has(node) ? [node] : [];
        });
        return toposort_1.topoSort(nodes, projectedDependencies);
    }
    /**
     * Return a topologically sorted list of non-Graph nodes in the entire subgraph
     */
    sortedLeaves() {
        // Project dependencies to leaf nodes
        const descendantsMap = new Map();
        findDescendants(this);
        function findDescendants(node) {
            const ret = [];
            if (node instanceof Graph) {
                for (const child of node.nodes) {
                    ret.push(...findDescendants(child));
                }
            }
            else {
                ret.push(node);
            }
            descendantsMap.set(node, ret);
            return ret;
        }
        const projectedDependencies = projectDependencies(this.deepDependencies(), (node) => { var _a; return (_a = descendantsMap.get(node)) !== null && _a !== void 0 ? _a : []; });
        return toposort_1.topoSort(new Set(projectedDependencies.keys()), projectedDependencies);
    }
    consoleLog(indent = 0) {
        process.stdout.write(' '.repeat(indent) + this + depString(this) + '\n');
        for (const node of this.nodes) {
            if (node instanceof Graph) {
                node.consoleLog(indent + 2);
            }
            else {
                process.stdout.write(' '.repeat(indent + 2) + node + depString(node) + '\n');
            }
        }
        function depString(node) {
            if (node.dependencies.length > 0) {
                return ` -> ${Array.from(node.dependencies).join(', ')}`;
            }
            return '';
        }
    }
    /**
     * Return the union of all dependencies of the descendants of this graph
     */
    deepDependencies() {
        const ret = new Map();
        for (const node of this.nodes) {
            recurse(node);
        }
        return ret;
        function recurse(node) {
            let deps = ret.get(node);
            if (!deps) {
                ret.set(node, deps = new Set());
            }
            for (let dep of node.dependencies) {
                deps.add(dep);
            }
            if (node instanceof Graph) {
                for (const child of node.nodes) {
                    recurse(child);
                }
            }
        }
    }
    /**
     * Return all non-Graph nodes
     */
    allLeaves() {
        const ret = [];
        recurse(this);
        return new GraphNodeCollection(ret);
        function recurse(node) {
            if (node instanceof Graph) {
                for (const child of node.nodes) {
                    recurse(child);
                }
            }
            else {
                ret.push(node);
            }
        }
    }
}
exports.Graph = Graph;
/**
 * A collection of graph nodes
 */
class GraphNodeCollection {
    constructor(nodes) {
        this.nodes = Array.from(nodes);
    }
    dependOn(...dependencies) {
        for (const node of this.nodes) {
            node.dependOn(...dependencies.filter(javascript_1.isDefined));
        }
    }
    /**
    * Returns the graph node that's shared between these nodes
    */
    commonAncestor() {
        const paths = new Array();
        for (const x of this.nodes) {
            paths.push(x.rootPath());
        }
        if (paths.length === 0) {
            throw new Error('Cannot find common ancestor between an empty set of nodes');
        }
        if (paths.length === 1) {
            const path = paths[0];
            if (path.length < 2) {
                throw new Error(`Cannot find ancestor of node without ancestor: ${path[0]}`);
            }
            return path[path.length - 2];
        }
        const originalPaths = [...paths];
        // Remove the first element of every path as long as the 2nd elements are all
        // the same -- this leaves the shared element in first place.
        //
        //   A, B, C, 1, 2    }---> C
        //   A, B, C, 3       }
        while (paths.every(path => paths[0].length >= 2 && path.length >= 2 && path[1] === paths[0][1])) {
            for (const path of paths) {
                path.shift();
            }
        }
        // If any of the paths are left with 1 element, there's no shared parent.
        if (paths.some(path => path.length < 2)) {
            throw new Error(`Could not determine a shared parent between nodes: ${originalPaths.map(nodes => nodes.map(n => n.id).join('/'))}`);
        }
        return paths[0][0];
    }
}
exports.GraphNodeCollection = GraphNodeCollection;
/**
 * Dependency map of nodes in this graph, taking into account dependencies between nodes in subgraphs
 *
 * Guaranteed to return an entry in the map for every node in the current graph.
 */
function projectDependencies(dependencies, project) {
    // Project keys
    for (const node of dependencies.keys()) {
        const projectedNodes = project(node);
        if (projectedNodes.length === 1 && projectedNodes[0] === node) {
            continue;
        } // Nothing to do, just for efficiency
        const deps = javascript_1.extract(dependencies, node);
        for (const projectedNode of projectedNodes) {
            javascript_1.addAll(dependencies.get(projectedNode), deps);
        }
    }
    // Project values. Ignore self-dependencies, they were just between nodes that were collapsed into the same node.
    for (const [node, deps] of dependencies.entries()) {
        const depset = new Set(javascript_1.flatMap(deps, project));
        depset.delete(node);
        dependencies.set(node, depset);
    }
    return dependencies;
}
function isGraph(x) {
    return x instanceof Graph;
}
exports.isGraph = isGraph;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJncmFwaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILHNEQUE0RTtBQUM1RSx5Q0FBc0M7QUFNdEMsTUFBYSxTQUFTO0lBU3BCLFlBQTRCLEVBQVUsRUFBRSxRQUEyQixFQUFFO1FBQXpDLE9BQUUsR0FBRixFQUFFLENBQVE7UUFKdEIsaUJBQVksR0FBbUIsRUFBRSxDQUFDO1FBS2hELElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztJQUN6QixDQUFDO0lBVk0sTUFBTSxDQUFDLEVBQUUsQ0FBSSxFQUFVLEVBQUUsSUFBTztRQUNyQyxPQUFPLElBQUksU0FBUyxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDckMsQ0FBQztJQVVEOzs7T0FHRztJQUNILElBQVcsUUFBUTtRQUNqQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQVcsT0FBTzs7UUFDaEIsTUFBTSxVQUFVLGVBQUcsSUFBSSxDQUFDLFdBQVcsMENBQUUsT0FBTyxtQ0FBSSxFQUFFLENBQUM7UUFDbkQsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksRUFBRSxHQUFHLFVBQVUsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFTSxRQUFRLENBQUMsR0FBRyxZQUE2QztRQUM5RCxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUMzRDtRQUNELElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxzQkFBUyxDQUFDLENBQUMsQ0FBQztJQUM1RCxDQUFDO0lBRU0sWUFBWSxDQUFDLElBQWtCO1FBQ3BDLElBQUksQ0FBQyxHQUFpQixJQUFJLENBQUM7UUFDM0IsTUFBTSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQixPQUFPLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDOUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUM7WUFDbEIsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVNLFFBQVE7UUFDYixJQUFJLENBQUMsR0FBaUIsSUFBSSxDQUFDO1FBQzNCLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEIsT0FBTyxDQUFDLENBQUMsV0FBVyxFQUFFO1lBQ3BCLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDO1lBQ2xCLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEI7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxJQUFXLElBQUk7UUFDYixJQUFJLENBQUMsR0FBaUIsSUFBSSxDQUFDO1FBQzNCLE9BQU8sQ0FBQyxDQUFDLFdBQVcsRUFBRTtZQUNwQixDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQztTQUNuQjtRQUNELE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUVELElBQVcsV0FBVztRQUNwQixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksZUFBZSxDQUFDLFdBQXFCO1FBQzFDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUM7UUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRU0sUUFBUTtRQUNiLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUM7SUFDaEQsQ0FBQztDQUNGO0FBbEZELDhCQWtGQztBQUVEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsaUJBQWlCO0lBQTlCO1FBQ21CLFlBQU8sR0FBbUIsRUFBRSxDQUFDO1FBQzdCLFlBQU8sR0FBbUIsRUFBRSxDQUFDO0lBcUJoRCxDQUFDO0lBbkJRLFFBQVEsQ0FBQyxHQUFHLE9BQXVCO1FBQ3hDLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO1lBQzVCLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDakMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUN6QjtZQUNELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzNCO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sUUFBUSxDQUFDLEdBQUcsT0FBdUI7UUFDeEMsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7WUFDNUIsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNqQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3pCO1lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDM0I7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7Q0FDRjtBQXZCRCw4Q0F1QkM7QUFFRCxNQUFhLGtCQUFrQjtJQUEvQjtRQUNtQixhQUFRLEdBQUcsSUFBSSxHQUFHLEVBQTJCLENBQUM7SUFTakUsQ0FBQztJQVBRLEdBQUcsQ0FBQyxHQUFNO1FBQ2YsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLEVBQUU7WUFBRSxPQUFPLENBQUMsQ0FBQztTQUFFO1FBQ3BCLE1BQU0sR0FBRyxHQUFHLElBQUksaUJBQWlCLEVBQUssQ0FBQztRQUN2QyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDNUIsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0NBQ0Y7QUFWRCxnREFVQztBQVNELE1BQWEsS0FBUyxTQUFRLFNBQVk7SUFPeEMsWUFBWSxJQUFZLEVBQUUsUUFBcUIsRUFBRTtRQUMvQyxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBSEosYUFBUSxHQUFHLElBQUksR0FBRyxFQUF3QixDQUFDO1FBSzFELElBQUksS0FBSyxDQUFDLEtBQUssRUFBRTtZQUNmLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDMUI7SUFDSCxDQUFDO0lBWk0sTUFBTSxDQUFDLEVBQUUsQ0FBTyxFQUFVLEVBQUUsSUFBTyxFQUFFLEtBQXNCO1FBQ2hFLE9BQU8sSUFBSSxLQUFLLENBQVEsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQVlELElBQVcsS0FBSztRQUNkLE9BQU8sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFTSxXQUFXLENBQUMsSUFBWTtRQUM3QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFFTSxRQUFRLENBQUMsSUFBa0I7UUFDaEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRU0sR0FBRyxDQUFDLEdBQUcsS0FBMEI7UUFDdEMsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMzQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDdkQ7WUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2xDO0lBQ0gsQ0FBQztJQUVNLE1BQU0sQ0FBQyxLQUFlO1FBQzNCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksY0FBYztRQUNuQiwyQ0FBMkM7UUFDM0MsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN6QixNQUFNLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDbEYsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDM0MsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDekI7WUFDRCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sbUJBQVEsQ0FBQyxLQUFLLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxZQUFZO1FBQ2pCLHFDQUFxQztRQUNyQyxNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsRUFBZ0MsQ0FBQztRQUMvRCxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEIsU0FBUyxlQUFlLENBQUMsSUFBa0I7WUFDekMsTUFBTSxHQUFHLEdBQW1CLEVBQUUsQ0FBQztZQUUvQixJQUFJLElBQUksWUFBWSxLQUFLLEVBQUU7Z0JBQ3pCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDOUIsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUNyQzthQUNGO2lCQUFNO2dCQUNMLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDaEI7WUFFRCxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztZQUM5QixPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUM7UUFFRCxNQUFNLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsd0JBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsbUNBQUksRUFBRSxHQUFBLENBQUMsQ0FBQztRQUNySCxPQUFPLG1CQUFRLENBQUMsSUFBSSxHQUFHLENBQUMscUJBQXFCLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQ2hGLENBQUM7SUFFTSxVQUFVLENBQUMsU0FBaUIsQ0FBQztRQUNsQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDekUsS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzdCLElBQUksSUFBSSxZQUFZLEtBQUssRUFBRTtnQkFDekIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDN0I7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQzthQUM5RTtTQUNGO1FBRUQsU0FBUyxTQUFTLENBQUMsSUFBa0I7WUFDbkMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQzthQUMxRDtZQUNELE9BQU8sRUFBRSxDQUFDO1FBQ1osQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNLLGdCQUFnQjtRQUN0QixNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsRUFBbUMsQ0FBQztRQUN2RCxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDN0IsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2Y7UUFDRCxPQUFPLEdBQUcsQ0FBQztRQUVYLFNBQVMsT0FBTyxDQUFDLElBQWtCO1lBQ2pDLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLElBQUksRUFBRTtnQkFDVCxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDO2FBQ2pDO1lBQ0QsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNqQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2Y7WUFDRCxJQUFJLElBQUksWUFBWSxLQUFLLEVBQUU7Z0JBQ3pCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDOUIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNoQjthQUNGO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7UUFDZCxNQUFNLEdBQUcsR0FBbUIsRUFBRSxDQUFDO1FBQy9CLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNkLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVwQyxTQUFTLE9BQU8sQ0FBQyxJQUFrQjtZQUNqQyxJQUFJLElBQUksWUFBWSxLQUFLLEVBQUU7Z0JBQ3pCLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDOUIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUNoQjthQUNGO2lCQUFNO2dCQUNMLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDaEI7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBbEpELHNCQWtKQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxtQkFBbUI7SUFHOUIsWUFBWSxLQUE2QjtRQUN2QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVNLFFBQVEsQ0FBQyxHQUFHLFlBQTZDO1FBQzlELEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxzQkFBUyxDQUFDLENBQUMsQ0FBQztTQUNsRDtJQUNILENBQUM7SUFFRDs7TUFFRTtJQUNLLGNBQWM7UUFDbkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQWtCLENBQUM7UUFDMUMsS0FBSyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzFCLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDMUI7UUFFRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkRBQTJELENBQUMsQ0FBQztTQUM5RTtRQUNELElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEIsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXRCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7YUFDOUU7WUFDRCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzlCO1FBRUQsTUFBTSxhQUFhLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1FBRWpDLDZFQUE2RTtRQUM3RSw2REFBNkQ7UUFDN0QsRUFBRTtRQUNGLDZCQUE2QjtRQUM3Qix1QkFBdUI7UUFDdkIsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQy9GLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO2dCQUN4QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDZDtTQUNGO1FBRUQseUVBQXlFO1FBQ3pFLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3JJO1FBRUQsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztDQUNGO0FBdERELGtEQXNEQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLG1CQUFtQixDQUFJLFlBQWtELEVBQUUsT0FBNEM7SUFDOUgsZUFBZTtJQUNmLEtBQUssTUFBTSxJQUFJLElBQUksWUFBWSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ3RDLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNyQyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLGNBQWMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFBRSxTQUFTO1NBQUUsQ0FBQyxxQ0FBcUM7UUFFbEgsTUFBTSxJQUFJLEdBQUcsb0JBQU8sQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFFLENBQUM7UUFDMUMsS0FBSyxNQUFNLGFBQWEsSUFBSSxjQUFjLEVBQUU7WUFDMUMsbUJBQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBRSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2hEO0tBQ0Y7SUFFRCxpSEFBaUg7SUFDakgsS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUUsRUFBRTtRQUNqRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxvQkFBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQy9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEIsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDaEM7SUFFRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDO0FBRUQsU0FBZ0IsT0FBTyxDQUFJLENBQWU7SUFDeEMsT0FBTyxDQUFDLFlBQVksS0FBSyxDQUFDO0FBQzVCLENBQUM7QUFGRCwwQkFFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQSBsaWJyYXJ5IGZvciBuZXN0ZWQgZ3JhcGhzXG4gKi9cbmltcG9ydCB7IGFkZEFsbCwgZXh0cmFjdCwgZmxhdE1hcCwgaXNEZWZpbmVkIH0gZnJvbSAnLi4vcHJpdmF0ZS9qYXZhc2NyaXB0JztcbmltcG9ydCB7IHRvcG9Tb3J0IH0gZnJvbSAnLi90b3Bvc29ydCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhOb2RlUHJvcHM8QT4ge1xuICByZWFkb25seSBkYXRhPzogQTtcbn1cblxuZXhwb3J0IGNsYXNzIEdyYXBoTm9kZTxBPiB7XG4gIHB1YmxpYyBzdGF0aWMgb2Y8QT4oaWQ6IHN0cmluZywgZGF0YTogQSkge1xuICAgIHJldHVybiBuZXcgR3JhcGhOb2RlKGlkLCB7IGRhdGEgfSk7XG4gIH1cblxuICBwdWJsaWMgcmVhZG9ubHkgZGVwZW5kZW5jaWVzOiBHcmFwaE5vZGU8QT5bXSA9IFtdO1xuICBwdWJsaWMgcmVhZG9ubHkgZGF0YT86IEE7XG4gIHByaXZhdGUgX3BhcmVudEdyYXBoPzogR3JhcGg8QT47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGlkOiBzdHJpbmcsIHByb3BzOiBHcmFwaE5vZGVQcm9wczxBPiA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdyYXBoLXdpZGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgbm9kZS4gUmVuZGVyZWQgYnkgam9pbmluZyB0aGUgSURzXG4gICAqIG9mIGFsbCBhbmNlc3RvcnMgd2l0aCBoeXBoZW5zLlxuICAgKi9cbiAgcHVibGljIGdldCB1bmlxdWVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFuY2VzdG9yUGF0aCh0aGlzLnJvb3QpLm1hcCh4ID0+IHguaWQpLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdW5pb24gb2YgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGlzIG5vZGUgYW5kIHRoZSBkZXBlbmRlbmNpZXMgb2YgYWxsXG4gICAqIHBhcmVudCBncmFwaHMuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFsbERlcHMoKTogR3JhcGhOb2RlPEE+W10ge1xuICAgIGNvbnN0IGZyb21QYXJlbnQgPSB0aGlzLnBhcmVudEdyYXBoPy5hbGxEZXBzID8/IFtdO1xuICAgIHJldHVybiBbLi4udGhpcy5kZXBlbmRlbmNpZXMsIC4uLmZyb21QYXJlbnRdO1xuICB9XG5cbiAgcHVibGljIGRlcGVuZE9uKC4uLmRlcGVuZGVuY2llczogQXJyYXk8R3JhcGhOb2RlPEE+IHwgdW5kZWZpbmVkPikge1xuICAgIGlmIChkZXBlbmRlbmNpZXMuaW5jbHVkZXModGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFkZCBkZXBlbmRlbmN5IG9uIHNlbGY6ICR7dGhpc31gKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmNpZXMucHVzaCguLi5kZXBlbmRlbmNpZXMuZmlsdGVyKGlzRGVmaW5lZCkpO1xuICB9XG5cbiAgcHVibGljIGFuY2VzdG9yUGF0aCh1cFRvOiBHcmFwaE5vZGU8QT4pOiBHcmFwaE5vZGU8QT5bXSB7XG4gICAgbGV0IHg6IEdyYXBoTm9kZTxBPiA9IHRoaXM7XG4gICAgY29uc3QgcmV0ID0gW3hdO1xuICAgIHdoaWxlICh4LnBhcmVudEdyYXBoICYmIHgucGFyZW50R3JhcGggIT09IHVwVG8pIHtcbiAgICAgIHggPSB4LnBhcmVudEdyYXBoO1xuICAgICAgcmV0LnVuc2hpZnQoeCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwdWJsaWMgcm9vdFBhdGgoKTogR3JhcGhOb2RlPEE+W10ge1xuICAgIGxldCB4OiBHcmFwaE5vZGU8QT4gPSB0aGlzO1xuICAgIGNvbnN0IHJldCA9IFt4XTtcbiAgICB3aGlsZSAoeC5wYXJlbnRHcmFwaCkge1xuICAgICAgeCA9IHgucGFyZW50R3JhcGg7XG4gICAgICByZXQudW5zaGlmdCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcm9vdCgpIHtcbiAgICBsZXQgeDogR3JhcGhOb2RlPEE+ID0gdGhpcztcbiAgICB3aGlsZSAoeC5wYXJlbnRHcmFwaCkge1xuICAgICAgeCA9IHgucGFyZW50R3JhcGg7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgcHVibGljIGdldCBwYXJlbnRHcmFwaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50R3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwdWJsaWMgX3NldFBhcmVudEdyYXBoKHBhcmVudEdyYXBoOiBHcmFwaDxBPikge1xuICAgIGlmICh0aGlzLl9wYXJlbnRHcmFwaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGFscmVhZHkgaGFzIGEgcGFyZW50Jyk7XG4gICAgfVxuICAgIHRoaXMuX3BhcmVudEdyYXBoID0gcGFyZW50R3JhcGg7XG4gIH1cblxuICBwdWJsaWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0oJHt0aGlzLmlkfSlgO1xuICB9XG59XG5cbi8qKlxuICogQSBkZXBlbmRlbmN5IHNldCB0aGF0IGNhbiBiZSBjb25zdHJ1Y3RlZCBwYXJ0aWFsbHkgYW5kIGxhdGVyIGZpbmlzaGVkXG4gKlxuICogSXQgZG9lc24ndCBtYXR0ZXIgaW4gd2hhdCBvcmRlciBzb3VyY2VzIGFuZCB0YXJnZXRzIGZvciB0aGUgZGVwZW5kZW5jeVxuICogcmVsYXRpb25zaGlwKHMpIGdldCBhZGRlZC4gVGhpcyBjbGFzcyBjYW4gc2VydmUgYXMgYSBzeW5jaHJvbml6YXRpb25cbiAqIHBvaW50IGlmIHRoZSBvcmRlciBpbiB3aGljaCBncmFwaCBub2RlcyBnZXQgYWRkZWQgdG8gdGhlIGdyYXBoIGlzIG5vdFxuICogd2VsbC1kZWZpbmVkLlxuICpcbiAqIFVzZWZ1bCB1dGlsaXR5IGR1cmluZyBncmFwaCBidWlsZGluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlcGVuZGVuY3lCdWlsZGVyPEE+IHtcbiAgcHJpdmF0ZSByZWFkb25seSB0YXJnZXRzOiBHcmFwaE5vZGU8QT5bXSA9IFtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZXM6IEdyYXBoTm9kZTxBPltdID0gW107XG5cbiAgcHVibGljIGRlcGVuZE9uKC4uLnRhcmdldHM6IEdyYXBoTm9kZTxBPltdKSB7XG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2YgdGhpcy5zb3VyY2VzKSB7XG4gICAgICAgIHNvdXJjZS5kZXBlbmRPbih0YXJnZXQpO1xuICAgICAgfVxuICAgICAgdGhpcy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgZGVwZW5kQnkoLi4uc291cmNlczogR3JhcGhOb2RlPEE+W10pIHtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0aGlzLnRhcmdldHMpIHtcbiAgICAgICAgc291cmNlLmRlcGVuZE9uKHRhcmdldCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGVwZW5kZW5jeUJ1aWxkZXJzPEssIEE+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBidWlsZGVycyA9IG5ldyBNYXA8SywgRGVwZW5kZW5jeUJ1aWxkZXI8QT4+KCk7XG5cbiAgcHVibGljIGdldChrZXk6IEspIHtcbiAgICBjb25zdCBiID0gdGhpcy5idWlsZGVycy5nZXQoa2V5KTtcbiAgICBpZiAoYikgeyByZXR1cm4gYjsgfVxuICAgIGNvbnN0IHJldCA9IG5ldyBEZXBlbmRlbmN5QnVpbGRlcjxBPigpO1xuICAgIHRoaXMuYnVpbGRlcnMuc2V0KGtleSwgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhQcm9wczxBPiBleHRlbmRzIEdyYXBoTm9kZVByb3BzPEE+IHtcbiAgLyoqXG4gICAqIEluaXRpYWwgbm9kZXMgaW4gdGhlIHdvcmtmbG93XG4gICAqL1xuICByZWFkb25seSBub2Rlcz86IEdyYXBoTm9kZTxBPltdO1xufVxuXG5leHBvcnQgY2xhc3MgR3JhcGg8QT4gZXh0ZW5kcyBHcmFwaE5vZGU8QT4ge1xuICBwdWJsaWMgc3RhdGljIG9mPEEsIEI+KGlkOiBzdHJpbmcsIGRhdGE6IEEsIG5vZGVzPzogR3JhcGhOb2RlPEI+W10pIHtcbiAgICByZXR1cm4gbmV3IEdyYXBoPEEgfCBCPihpZCwgeyBkYXRhLCBub2RlcyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgY2hpbGRyZW4gPSBuZXcgTWFwPHN0cmluZywgR3JhcGhOb2RlPEE+PigpO1xuXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgcHJvcHM6IEdyYXBoUHJvcHM8QT49e30pIHtcbiAgICBzdXBlcihuYW1lLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMubm9kZXMpIHtcbiAgICAgIHRoaXMuYWRkKC4uLnByb3BzLm5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IG5vZGVzKCkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMuY2hpbGRyZW4udmFsdWVzKCkpO1xuICB9XG5cbiAgcHVibGljIHRyeUdldENoaWxkKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmdldChuYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBjb250YWlucyhub2RlOiBHcmFwaE5vZGU8QT4pIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5oYXMobm9kZSk7XG4gIH1cblxuICBwdWJsaWMgYWRkKC4uLm5vZGVzOiBBcnJheTxHcmFwaE5vZGU8QT4+KSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBub2RlLl9zZXRQYXJlbnRHcmFwaCh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmhhcyhub2RlLmlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgd2l0aCBkdXBsaWNhdGUgaWQ6ICR7bm9kZS5pZH1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGRyZW4uc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhYnNvcmIob3RoZXI6IEdyYXBoPEE+KSB7XG4gICAgdGhpcy5hZGQoLi4ub3RoZXIubm9kZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0b3BvbG9naWNhbGx5IHNvcnRlZCB0cmFuY2hlcyBvZiBub2RlcyBhdCB0aGlzIGdyYXBoIGxldmVsXG4gICAqL1xuICBwdWJsaWMgc29ydGVkQ2hpbGRyZW4oKTogR3JhcGhOb2RlPEE+W11bXSB7XG4gICAgLy8gUHJvamVjdCBkZXBlbmRlbmNpZXMgdG8gY3VycmVudCBjaGlsZHJlblxuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICBjb25zdCBwcm9qZWN0ZWREZXBlbmRlbmNpZXMgPSBwcm9qZWN0RGVwZW5kZW5jaWVzKHRoaXMuZGVlcERlcGVuZGVuY2llcygpLCAobm9kZSkgPT4ge1xuICAgICAgd2hpbGUgKCFub2Rlcy5oYXMobm9kZSkgJiYgbm9kZS5wYXJlbnRHcmFwaCkge1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRHcmFwaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2Rlcy5oYXMobm9kZSkgPyBbbm9kZV0gOiBbXTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3BvU29ydChub2RlcywgcHJvamVjdGVkRGVwZW5kZW5jaWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSB0b3BvbG9naWNhbGx5IHNvcnRlZCBsaXN0IG9mIG5vbi1HcmFwaCBub2RlcyBpbiB0aGUgZW50aXJlIHN1YmdyYXBoXG4gICAqL1xuICBwdWJsaWMgc29ydGVkTGVhdmVzKCk6IEdyYXBoTm9kZTxBPltdW10ge1xuICAgIC8vIFByb2plY3QgZGVwZW5kZW5jaWVzIHRvIGxlYWYgbm9kZXNcbiAgICBjb25zdCBkZXNjZW5kYW50c01hcCA9IG5ldyBNYXA8R3JhcGhOb2RlPEE+LCBHcmFwaE5vZGU8QT5bXT4oKTtcbiAgICBmaW5kRGVzY2VuZGFudHModGhpcyk7XG5cbiAgICBmdW5jdGlvbiBmaW5kRGVzY2VuZGFudHMobm9kZTogR3JhcGhOb2RlPEE+KTogR3JhcGhOb2RlPEE+W10ge1xuICAgICAgY29uc3QgcmV0OiBHcmFwaE5vZGU8QT5bXSA9IFtdO1xuXG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyYXBoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICAgIHJldC5wdXNoKC4uLmZpbmREZXNjZW5kYW50cyhjaGlsZCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgZGVzY2VuZGFudHNNYXAuc2V0KG5vZGUsIHJldCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNvbnN0IHByb2plY3RlZERlcGVuZGVuY2llcyA9IHByb2plY3REZXBlbmRlbmNpZXModGhpcy5kZWVwRGVwZW5kZW5jaWVzKCksIChub2RlKSA9PiBkZXNjZW5kYW50c01hcC5nZXQobm9kZSkgPz8gW10pO1xuICAgIHJldHVybiB0b3BvU29ydChuZXcgU2V0KHByb2plY3RlZERlcGVuZGVuY2llcy5rZXlzKCkpLCBwcm9qZWN0ZWREZXBlbmRlbmNpZXMpO1xuICB9XG5cbiAgcHVibGljIGNvbnNvbGVMb2coaW5kZW50OiBudW1iZXIgPSAwKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJyAnLnJlcGVhdChpbmRlbnQpICsgdGhpcyArIGRlcFN0cmluZyh0aGlzKSArICdcXG4nKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBHcmFwaCkge1xuICAgICAgICBub2RlLmNvbnNvbGVMb2coaW5kZW50ICsgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnICcucmVwZWF0KGluZGVudCArIDIpICsgbm9kZSArIGRlcFN0cmluZyhub2RlKSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXBTdHJpbmcobm9kZTogR3JhcGhOb2RlPEE+KSB7XG4gICAgICBpZiAobm9kZS5kZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gYCAtPiAke0FycmF5LmZyb20obm9kZS5kZXBlbmRlbmNpZXMpLmpvaW4oJywgJyl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB1bmlvbiBvZiBhbGwgZGVwZW5kZW5jaWVzIG9mIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIGdyYXBoXG4gICAqL1xuICBwcml2YXRlIGRlZXBEZXBlbmRlbmNpZXMoKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IE1hcDxHcmFwaE5vZGU8QT4sIFNldDxHcmFwaE5vZGU8QT4+PigpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICByZWN1cnNlKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShub2RlOiBHcmFwaE5vZGU8QT4pIHtcbiAgICAgIGxldCBkZXBzID0gcmV0LmdldChub2RlKTtcbiAgICAgIGlmICghZGVwcykge1xuICAgICAgICByZXQuc2V0KG5vZGUsIGRlcHMgPSBuZXcgU2V0KCkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgZGVwIG9mIG5vZGUuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGRlcHMuYWRkKGRlcCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEdyYXBoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5ub2Rlcykge1xuICAgICAgICAgIHJlY3Vyc2UoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgbm9uLUdyYXBoIG5vZGVzXG4gICAqL1xuICBwdWJsaWMgYWxsTGVhdmVzKCk6IEdyYXBoTm9kZUNvbGxlY3Rpb248QT4ge1xuICAgIGNvbnN0IHJldDogR3JhcGhOb2RlPEE+W10gPSBbXTtcbiAgICByZWN1cnNlKHRoaXMpO1xuICAgIHJldHVybiBuZXcgR3JhcGhOb2RlQ29sbGVjdGlvbihyZXQpO1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShub2RlOiBHcmFwaE5vZGU8QT4pIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgR3JhcGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLm5vZGVzKSB7XG4gICAgICAgICAgcmVjdXJzZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBncmFwaCBub2Rlc1xuICovXG5leHBvcnQgY2xhc3MgR3JhcGhOb2RlQ29sbGVjdGlvbjxBPiB7XG4gIHB1YmxpYyByZWFkb25seSBub2RlczogR3JhcGhOb2RlPEE+W107XG5cbiAgY29uc3RydWN0b3Iobm9kZXM6IEl0ZXJhYmxlPEdyYXBoTm9kZTxBPj4pIHtcbiAgICB0aGlzLm5vZGVzID0gQXJyYXkuZnJvbShub2Rlcyk7XG4gIH1cblxuICBwdWJsaWMgZGVwZW5kT24oLi4uZGVwZW5kZW5jaWVzOiBBcnJheTxHcmFwaE5vZGU8QT4gfCB1bmRlZmluZWQ+KSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZXMpIHtcbiAgICAgIG5vZGUuZGVwZW5kT24oLi4uZGVwZW5kZW5jaWVzLmZpbHRlcihpc0RlZmluZWQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBSZXR1cm5zIHRoZSBncmFwaCBub2RlIHRoYXQncyBzaGFyZWQgYmV0d2VlbiB0aGVzZSBub2Rlc1xuICAqL1xuICBwdWJsaWMgY29tbW9uQW5jZXN0b3IoKSB7XG4gICAgY29uc3QgcGF0aHMgPSBuZXcgQXJyYXk8R3JhcGhOb2RlPEE+W10+KCk7XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMubm9kZXMpIHtcbiAgICAgIHBhdGhzLnB1c2goeC5yb290UGF0aCgpKTtcbiAgICB9XG5cbiAgICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGNvbW1vbiBhbmNlc3RvciBiZXR3ZWVuIGFuIGVtcHR5IHNldCBvZiBub2RlcycpO1xuICAgIH1cbiAgICBpZiAocGF0aHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBwYXRoID0gcGF0aHNbMF07XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhbmNlc3RvciBvZiBub2RlIHdpdGhvdXQgYW5jZXN0b3I6ICR7cGF0aFswXX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoW3BhdGgubGVuZ3RoIC0gMl07XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxQYXRocyA9IFsuLi5wYXRoc107XG5cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IGVsZW1lbnQgb2YgZXZlcnkgcGF0aCBhcyBsb25nIGFzIHRoZSAybmQgZWxlbWVudHMgYXJlIGFsbFxuICAgIC8vIHRoZSBzYW1lIC0tIHRoaXMgbGVhdmVzIHRoZSBzaGFyZWQgZWxlbWVudCBpbiBmaXJzdCBwbGFjZS5cbiAgICAvL1xuICAgIC8vICAgQSwgQiwgQywgMSwgMiAgICB9LS0tPiBDXG4gICAgLy8gICBBLCBCLCBDLCAzICAgICAgIH1cbiAgICB3aGlsZSAocGF0aHMuZXZlcnkocGF0aCA9PiBwYXRoc1swXS5sZW5ndGggPj0gMiAmJiBwYXRoLmxlbmd0aCA+PSAyICYmIHBhdGhbMV0gPT09IHBhdGhzWzBdWzFdKSkge1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIHBhdGguc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgdGhlIHBhdGhzIGFyZSBsZWZ0IHdpdGggMSBlbGVtZW50LCB0aGVyZSdzIG5vIHNoYXJlZCBwYXJlbnQuXG4gICAgaWYgKHBhdGhzLnNvbWUocGF0aCA9PiBwYXRoLmxlbmd0aCA8IDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBkZXRlcm1pbmUgYSBzaGFyZWQgcGFyZW50IGJldHdlZW4gbm9kZXM6ICR7b3JpZ2luYWxQYXRocy5tYXAobm9kZXMgPT4gbm9kZXMubWFwKG4gPT4gbi5pZCkuam9pbignLycpKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aHNbMF1bMF07XG4gIH1cbn1cblxuLyoqXG4gKiBEZXBlbmRlbmN5IG1hcCBvZiBub2RlcyBpbiB0aGlzIGdyYXBoLCB0YWtpbmcgaW50byBhY2NvdW50IGRlcGVuZGVuY2llcyBiZXR3ZWVuIG5vZGVzIGluIHN1YmdyYXBoc1xuICpcbiAqIEd1YXJhbnRlZWQgdG8gcmV0dXJuIGFuIGVudHJ5IGluIHRoZSBtYXAgZm9yIGV2ZXJ5IG5vZGUgaW4gdGhlIGN1cnJlbnQgZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIHByb2plY3REZXBlbmRlbmNpZXM8QT4oZGVwZW5kZW5jaWVzOiBNYXA8R3JhcGhOb2RlPEE+LCBTZXQ8R3JhcGhOb2RlPEE+Pj4sIHByb2plY3Q6ICh4OiBHcmFwaE5vZGU8QT4pID0+IEdyYXBoTm9kZTxBPltdKSB7XG4gIC8vIFByb2plY3Qga2V5c1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgZGVwZW5kZW5jaWVzLmtleXMoKSkge1xuICAgIGNvbnN0IHByb2plY3RlZE5vZGVzID0gcHJvamVjdChub2RlKTtcbiAgICBpZiAocHJvamVjdGVkTm9kZXMubGVuZ3RoID09PSAxICYmIHByb2plY3RlZE5vZGVzWzBdID09PSBub2RlKSB7IGNvbnRpbnVlOyB9IC8vIE5vdGhpbmcgdG8gZG8sIGp1c3QgZm9yIGVmZmljaWVuY3lcblxuICAgIGNvbnN0IGRlcHMgPSBleHRyYWN0KGRlcGVuZGVuY2llcywgbm9kZSkhO1xuICAgIGZvciAoY29uc3QgcHJvamVjdGVkTm9kZSBvZiBwcm9qZWN0ZWROb2Rlcykge1xuICAgICAgYWRkQWxsKGRlcGVuZGVuY2llcy5nZXQocHJvamVjdGVkTm9kZSkhLCBkZXBzKTtcbiAgICB9XG4gIH1cblxuICAvLyBQcm9qZWN0IHZhbHVlcy4gSWdub3JlIHNlbGYtZGVwZW5kZW5jaWVzLCB0aGV5IHdlcmUganVzdCBiZXR3ZWVuIG5vZGVzIHRoYXQgd2VyZSBjb2xsYXBzZWQgaW50byB0aGUgc2FtZSBub2RlLlxuICBmb3IgKGNvbnN0IFtub2RlLCBkZXBzXSBvZiBkZXBlbmRlbmNpZXMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZGVwc2V0ID0gbmV3IFNldChmbGF0TWFwKGRlcHMsIHByb2plY3QpKTtcbiAgICBkZXBzZXQuZGVsZXRlKG5vZGUpO1xuICAgIGRlcGVuZGVuY2llcy5zZXQobm9kZSwgZGVwc2V0KTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0dyYXBoPEE+KHg6IEdyYXBoTm9kZTxBPik6IHggaXMgR3JhcGg8QT4ge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIEdyYXBoO1xufSJdfQ==