"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stackVariableNamespace = exports.mergeBuildSpecs = exports.mergeCodeBuildOptions = exports.CodeBuildFactory = void 0;
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const codebuild = require("@aws-cdk/aws-codebuild");
const codepipeline_actions = require("@aws-cdk/aws-codepipeline-actions");
const ec2 = require("@aws-cdk/aws-ec2");
const core_1 = require("@aws-cdk/core");
const constructs_1 = require("constructs");
const pipeline_queries_1 = require("../helpers-internal/pipeline-queries");
const construct_internals_1 = require("../private/construct-internals");
const javascript_1 = require("../private/javascript");
/**
 * Produce a CodeBuild project from a ShellStep and some CodeBuild-specific customizations
 *
 * The functionality here is shared between the `CodePipeline` translating a `ShellStep` into
 * a CodeBuild project, as well as the `CodeBuildStep` straight up.
 */
class CodeBuildFactory {
    constructor(constructId, props) {
        var _a;
        this.constructId = constructId;
        this.props = props;
        this.stepId = (_a = props.stepId) !== null && _a !== void 0 ? _a : constructId;
    }
    // eslint-disable-next-line max-len
    static fromShellStep(constructId, shellStep, additional) {
        return new CodeBuildFactory(constructId, {
            commands: shellStep.commands,
            env: shellStep.env,
            envFromCfnOutputs: shellStep.envFromCfnOutputs,
            inputs: shellStep.inputs,
            outputs: shellStep.outputs,
            stepId: shellStep.id,
            installCommands: shellStep.installCommands,
            ...additional,
        });
    }
    static fromCodeBuildStep(constructId, step, additional) {
        const factory = CodeBuildFactory.fromShellStep(constructId, step, {
            projectName: step.projectName,
            role: step.role,
            projectOptions: {
                buildEnvironment: step.buildEnvironment,
                rolePolicy: step.rolePolicyStatements,
                securityGroups: step.securityGroups,
                partialBuildSpec: step.partialBuildSpec,
                vpc: step.vpc,
                subnetSelection: step.subnetSelection,
                ...additional === null || additional === void 0 ? void 0 : additional.projectOptions,
            },
            ...additional,
        });
        return {
            produceAction: (stage, options) => {
                const result = factory.produceAction(stage, options);
                if (result.project) {
                    step._setProject(result.project);
                }
                return result;
            },
        };
    }
    get project() {
        if (!this._project) {
            throw new Error('Project becomes available after produce() has been called');
        }
        return this._project;
    }
    produceAction(stage, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const projectOptions = mergeCodeBuildOptions(options.codeBuildDefaults, this.props.projectOptions);
        const inputs = (_a = this.props.inputs) !== null && _a !== void 0 ? _a : [];
        const outputs = (_b = this.props.outputs) !== null && _b !== void 0 ? _b : [];
        const mainInput = inputs.find(x => x.directory === '.');
        const extraInputs = inputs.filter(x => x.directory !== '.');
        const inputArtifact = mainInput
            ? options.artifacts.toCodePipeline(mainInput.fileSet)
            : options.fallbackArtifact;
        const extraInputArtifacts = extraInputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        const outputArtifacts = outputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        if (!inputArtifact) {
            // This should actually never happen because CodeBuild projects shouldn't be added before the
            // Source, which always produces at least an artifact.
            throw new Error(`CodeBuild action '${this.stepId}' requires an input (and the pipeline doesn't have a Source to fall back to). Add an input or a pipeline source.`);
        }
        const installCommands = [
            ...generateInputArtifactLinkCommands(options.artifacts, extraInputs),
            ...(_c = this.props.installCommands) !== null && _c !== void 0 ? _c : [],
        ];
        const buildSpecHere = codebuild.BuildSpec.fromObject({
            version: '0.2',
            phases: {
                install: ((_d = installCommands.length) !== null && _d !== void 0 ? _d : 0) > 0 ? { commands: installCommands } : undefined,
                build: this.props.commands.length > 0 ? { commands: this.props.commands } : undefined,
            },
            artifacts: javascript_1.noEmptyObject(renderArtifactsBuildSpec(options.artifacts, (_e = this.props.outputs) !== null && _e !== void 0 ? _e : [])),
        });
        // Partition environment variables into environment variables that can go on the project
        // and environment variables that MUST go in the pipeline (those that reference CodePipeline variables)
        const env = javascript_1.noUndefined((_f = this.props.env) !== null && _f !== void 0 ? _f : {});
        const [actionEnvs, projectEnvs] = javascript_1.partition(Object.entries(env !== null && env !== void 0 ? env : {}), ([, v]) => containsPipelineVariable(v));
        const environment = mergeBuildEnvironments((_g = projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.buildEnvironment) !== null && _g !== void 0 ? _g : {}, {
            environmentVariables: javascript_1.noEmptyObject(javascript_1.mapValues(javascript_1.mkdict(projectEnvs), value => ({ value }))),
        });
        const fullBuildSpec = (projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.partialBuildSpec) ? codebuild.mergeBuildSpecs(projectOptions.partialBuildSpec, buildSpecHere)
            : buildSpecHere;
        const osFromEnvironment = environment.buildImage && environment.buildImage instanceof codebuild.WindowsBuildImage
            ? ec2.OperatingSystemType.WINDOWS
            : ec2.OperatingSystemType.LINUX;
        const actualBuildSpec = filterBuildSpecCommands(fullBuildSpec, osFromEnvironment);
        const scope = (_h = this.props.scope) !== null && _h !== void 0 ? _h : options.scope;
        let projectBuildSpec;
        if (this.props.passBuildSpecViaCloudAssembly) {
            // Write to disk and replace with a reference
            const relativeSpecFile = `buildspec-${constructs_1.Node.of(scope).addr}-${this.constructId}.yaml`;
            const absSpecFile = path.join(construct_internals_1.cloudAssemblyBuildSpecDir(scope), relativeSpecFile);
            // This should resolve to a pure JSON string. If it resolves to an object, it's a CFN
            // expression, and we can't support that yet. Maybe someday if we think really hard about it.
            const fileContents = core_1.Stack.of(scope).resolve(actualBuildSpec.toBuildSpec());
            if (typeof fileContents !== 'string') {
                throw new Error(`This BuildSpec contains CloudFormation references and is supported by publishInParallel=false: ${JSON.stringify(fileContents, undefined, 2)}`);
            }
            fs.writeFileSync(absSpecFile, fileContents, { encoding: 'utf-8' });
            projectBuildSpec = codebuild.BuildSpec.fromSourceFilename(relativeSpecFile);
        }
        else {
            projectBuildSpec = actualBuildSpec;
        }
        // A hash over the values that make the CodeBuild Project unique (and necessary
        // to restart the pipeline if one of them changes). projectName is not necessary to include
        // here because the pipeline will definitely restart if projectName changes.
        // (Resolve tokens)
        const projectConfigHash = hash(core_1.Stack.of(scope).resolve({
            environment: serializeBuildEnvironment(environment),
            buildSpecString: actualBuildSpec.toBuildSpec(),
        }));
        const actionName = (_j = options.actionName) !== null && _j !== void 0 ? _j : this.stepId;
        let projectScope = scope;
        if ((_k = this.props.additionalConstructLevel) !== null && _k !== void 0 ? _k : true) {
            projectScope = construct_internals_1.obtainScope(scope, actionName);
        }
        const project = new codebuild.PipelineProject(projectScope, this.constructId, {
            projectName: this.props.projectName,
            environment,
            vpc: projectOptions.vpc,
            subnetSelection: projectOptions.subnetSelection,
            securityGroups: projectOptions.securityGroups,
            buildSpec: projectBuildSpec,
            role: this.props.role,
        });
        if (this.props.additionalDependable) {
            project.node.addDependency(this.props.additionalDependable);
        }
        if (projectOptions.rolePolicy !== undefined) {
            projectOptions.rolePolicy.forEach(policyStatement => {
                project.addToRolePolicy(policyStatement);
            });
        }
        const queries = new pipeline_queries_1.PipelineQueries(options.pipeline);
        const stackOutputEnv = javascript_1.mapValues((_l = this.props.envFromCfnOutputs) !== null && _l !== void 0 ? _l : {}, outputRef => `#{${stackVariableNamespace(queries.producingStack(outputRef))}.${outputRef.outputName}}`);
        const configHashEnv = options.beforeSelfMutation
            ? { _PROJECT_CONFIG_HASH: projectConfigHash }
            : {};
        stage.addAction(new codepipeline_actions.CodeBuildAction({
            actionName: actionName,
            input: inputArtifact,
            extraInputs: extraInputArtifacts,
            outputs: outputArtifacts,
            project,
            runOrder: options.runOrder,
            // Inclusion of the hash here will lead to the pipeline structure for any changes
            // made the config of the underlying CodeBuild Project.
            // Hence, the pipeline will be restarted. This is necessary if the users
            // adds (for example) build or test commands to the buildspec.
            environmentVariables: javascript_1.noEmptyObject(cbEnv({
                ...javascript_1.mkdict(actionEnvs),
                ...configHashEnv,
                ...stackOutputEnv,
            })),
        }));
        this._project = project;
        return { runOrdersConsumed: 1, project };
    }
}
exports.CodeBuildFactory = CodeBuildFactory;
/**
 * Generate commands to move additional input artifacts into the right place
 */
function generateInputArtifactLinkCommands(artifacts, inputs) {
    return inputs.map(input => {
        const fragments = [];
        if (!['.', '..'].includes(path.dirname(input.directory))) {
            fragments.push(`mkdir -p -- "${input.directory}"`);
        }
        const artifact = artifacts.toCodePipeline(input.fileSet);
        fragments.push(`ln -s -- "$CODEBUILD_SRC_DIR_${artifact.artifactName}" "${input.directory}"`);
        return fragments.join(' && ');
    });
}
function renderArtifactsBuildSpec(artifactMap, outputs) {
    // save the generated files in the output artifact
    // This part of the buildspec has to look completely different depending on whether we're
    // using secondary artifacts or not.
    if (outputs.length === 0) {
        return {};
    }
    if (outputs.length === 1) {
        return {
            'base-directory': outputs[0].directory,
            'files': '**/*',
        };
    }
    const secondary = {};
    for (const output of outputs) {
        const art = artifactMap.toCodePipeline(output.fileSet);
        if (!art.artifactName) {
            throw new Error('You must give the output artifact a name');
        }
        secondary[art.artifactName] = {
            'base-directory': output.directory,
            'files': '**/*',
        };
    }
    return { 'secondary-artifacts': secondary };
}
function mergeCodeBuildOptions(...opts) {
    const xs = [{}, ...opts.filter(isDefined)];
    while (xs.length > 1) {
        const [a, b] = xs.splice(xs.length - 2, 2);
        xs.push(merge2(a, b));
    }
    return xs[0];
    function merge2(a, b) {
        var _a, _b, _c, _d, _e, _f;
        return {
            buildEnvironment: mergeBuildEnvironments(a.buildEnvironment, b.buildEnvironment),
            rolePolicy: definedArray([...(_a = a.rolePolicy) !== null && _a !== void 0 ? _a : [], ...(_b = b.rolePolicy) !== null && _b !== void 0 ? _b : []]),
            securityGroups: definedArray([...(_c = a.securityGroups) !== null && _c !== void 0 ? _c : [], ...(_d = b.securityGroups) !== null && _d !== void 0 ? _d : []]),
            partialBuildSpec: mergeBuildSpecs(a.partialBuildSpec, b.partialBuildSpec),
            vpc: (_e = b.vpc) !== null && _e !== void 0 ? _e : a.vpc,
            subnetSelection: (_f = b.subnetSelection) !== null && _f !== void 0 ? _f : a.subnetSelection,
        };
    }
}
exports.mergeCodeBuildOptions = mergeCodeBuildOptions;
function mergeBuildEnvironments(a, b) {
    var _a, _b, _c;
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return {
        buildImage: (_a = b.buildImage) !== null && _a !== void 0 ? _a : a.buildImage,
        computeType: (_b = b.computeType) !== null && _b !== void 0 ? _b : a.computeType,
        environmentVariables: {
            ...a.environmentVariables,
            ...b.environmentVariables,
        },
        privileged: (_c = b.privileged) !== null && _c !== void 0 ? _c : a.privileged,
    };
}
function mergeBuildSpecs(a, b) {
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return codebuild.mergeBuildSpecs(a, b);
}
exports.mergeBuildSpecs = mergeBuildSpecs;
function isDefined(x) {
    return x !== undefined;
}
function hash(obj) {
    const d = crypto.createHash('sha256');
    d.update(JSON.stringify(obj));
    return d.digest('hex');
}
/**
 * Serialize a build environment to data (get rid of constructs & objects), so we can JSON.stringify it
 */
function serializeBuildEnvironment(env) {
    var _a, _b, _c, _d, _e;
    return {
        privileged: env.privileged,
        environmentVariables: env.environmentVariables,
        type: (_a = env.buildImage) === null || _a === void 0 ? void 0 : _a.type,
        imageId: (_b = env.buildImage) === null || _b === void 0 ? void 0 : _b.imageId,
        computeType: env.computeType,
        imagePullPrincipalType: (_c = env.buildImage) === null || _c === void 0 ? void 0 : _c.imagePullPrincipalType,
        secretsManagerArn: (_e = (_d = env.buildImage) === null || _d === void 0 ? void 0 : _d.secretsManagerCredentials) === null || _e === void 0 ? void 0 : _e.secretArn,
    };
}
function stackVariableNamespace(stack) {
    return stack.stackArtifactId;
}
exports.stackVariableNamespace = stackVariableNamespace;
/**
 * Whether the given string contains a reference to a CodePipeline variable
 */
function containsPipelineVariable(s) {
    return !!s.match(/#\{[^}]+\}/);
}
/**
 * Turn a collection into a collection of CodePipeline environment variables
 */
function cbEnv(xs) {
    return javascript_1.mkdict(Object.entries(xs)
        .filter(([, v]) => v !== undefined)
        .map(([k, v]) => [k, { value: v }]));
}
function definedArray(xs) {
    return xs.length > 0 ? xs : undefined;
}
/**
 * If lines in the buildspec start with '!WINDOWS!' or '!LINUX!', only render them on that platform.
 *
 * Very private protocol for now, but may come in handy in other libraries as well.
 */
function filterBuildSpecCommands(buildSpec, osType) {
    if (!buildSpec.isImmediate) {
        return buildSpec;
    }
    const spec = buildSpec.spec;
    const winTag = '!WINDOWS!';
    const linuxTag = '!LINUX!';
    const expectedTag = osType === ec2.OperatingSystemType.WINDOWS ? winTag : linuxTag;
    return codebuild.BuildSpec.fromObject(recurse(spec));
    function recurse(x) {
        if (Array.isArray(x)) {
            const ret = [];
            for (const el of x) {
                const [tag, payload] = extractTag(el);
                if (tag === undefined || tag === expectedTag) {
                    ret.push(payload);
                }
            }
            return ret;
        }
        if (x && typeof x === 'object') {
            return javascript_1.mapValues(x, recurse);
        }
        return x;
    }
    function extractTag(x) {
        if (typeof x !== 'string') {
            return [undefined, x];
        }
        for (const tag of [winTag, linuxTag]) {
            if (x.startsWith(tag)) {
                return [tag, x.substr(tag.length)];
            }
        }
        return [undefined, x];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2NvZGVidWlsZC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiX2NvZGVidWlsZC1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLG9EQUFvRDtBQUVwRCwwRUFBMEU7QUFDMUUsd0NBQXdDO0FBRXhDLHdDQUFtRDtBQUNuRCwyQ0FBNkM7QUFFN0MsMkVBQXVFO0FBQ3ZFLHdFQUF3RjtBQUN4RixzREFBaUc7QUFxR2pHOzs7OztHQUtHO0FBQ0gsTUFBYSxnQkFBZ0I7SUE2QzNCLFlBQ21CLFdBQW1CLEVBQ25CLEtBQTRCOztRQUQ1QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtRQUNuQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUU3QyxJQUFJLENBQUMsTUFBTSxTQUFHLEtBQUssQ0FBQyxNQUFNLG1DQUFJLFdBQVcsQ0FBQztJQUM1QyxDQUFDO0lBakRELG1DQUFtQztJQUM1QixNQUFNLENBQUMsYUFBYSxDQUFDLFdBQW1CLEVBQUUsU0FBb0IsRUFBRSxVQUEyQztRQUNoSCxPQUFPLElBQUksZ0JBQWdCLENBQUMsV0FBVyxFQUFFO1lBQ3ZDLFFBQVEsRUFBRSxTQUFTLENBQUMsUUFBUTtZQUM1QixHQUFHLEVBQUUsU0FBUyxDQUFDLEdBQUc7WUFDbEIsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLGlCQUFpQjtZQUM5QyxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU07WUFDeEIsT0FBTyxFQUFFLFNBQVMsQ0FBQyxPQUFPO1lBQzFCLE1BQU0sRUFBRSxTQUFTLENBQUMsRUFBRTtZQUNwQixlQUFlLEVBQUUsU0FBUyxDQUFDLGVBQWU7WUFDMUMsR0FBRyxVQUFVO1NBQ2QsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxXQUFtQixFQUFFLElBQW1CLEVBQUUsVUFBMkM7UUFDbkgsTUFBTSxPQUFPLEdBQUcsZ0JBQWdC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QUFDO1NBQUU7UUFDckQsS0FBSyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFBRTtZQUNwQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2FBQUU7U0FDL0Q7UUFDRCxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY29kZWJ1aWxkIGZyb20gJ0Bhd3MtY2RrL2F3cy1jb2RlYnVpbGQnO1xuaW1wb3J0ICogYXMgY29kZXBpcGVsaW5lIGZyb20gJ0Bhd3MtY2RrL2F3cy1jb2RlcGlwZWxpbmUnO1xuaW1wb3J0ICogYXMgY29kZXBpcGVsaW5lX2FjdGlvbnMgZnJvbSAnQGF3cy1jZGsvYXdzLWNvZGVwaXBlbGluZS1hY3Rpb25zJztcbmltcG9ydCAqIGFzIGVjMiBmcm9tICdAYXdzLWNkay9hd3MtZWMyJztcbmltcG9ydCAqIGFzIGlhbSBmcm9tICdAYXdzLWNkay9hd3MtaWFtJztcbmltcG9ydCB7IElEZXBlbmRhYmxlLCBTdGFjayB9IGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuaW1wb3J0IHsgQ29uc3RydWN0LCBOb2RlIH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBGaWxlU2V0TG9jYXRpb24sIFNoZWxsU3RlcCwgU3RhY2tEZXBsb3ltZW50LCBTdGFja091dHB1dFJlZmVyZW5jZSB9IGZyb20gJy4uL2JsdWVwcmludCc7XG5pbXBvcnQgeyBQaXBlbGluZVF1ZXJpZXMgfSBmcm9tICcuLi9oZWxwZXJzLWludGVybmFsL3BpcGVsaW5lLXF1ZXJpZXMnO1xuaW1wb3J0IHsgY2xvdWRBc3NlbWJseUJ1aWxkU3BlY0Rpciwgb2J0YWluU2NvcGUgfSBmcm9tICcuLi9wcml2YXRlL2NvbnN0cnVjdC1pbnRlcm5hbHMnO1xuaW1wb3J0IHsgbWFwVmFsdWVzLCBta2RpY3QsIG5vRW1wdHlPYmplY3QsIG5vVW5kZWZpbmVkLCBwYXJ0aXRpb24gfSBmcm9tICcuLi9wcml2YXRlL2phdmFzY3JpcHQnO1xuaW1wb3J0IHsgQXJ0aWZhY3RNYXAgfSBmcm9tICcuL2FydGlmYWN0LW1hcCc7XG5pbXBvcnQgeyBDb2RlQnVpbGRTdGVwIH0gZnJvbSAnLi9jb2RlYnVpbGQtc3RlcCc7XG5pbXBvcnQgeyBDb2RlQnVpbGRPcHRpb25zIH0gZnJvbSAnLi9jb2RlcGlwZWxpbmUnO1xuaW1wb3J0IHsgSUNvZGVQaXBlbGluZUFjdGlvbkZhY3RvcnksIFByb2R1Y2VBY3Rpb25PcHRpb25zLCBDb2RlUGlwZWxpbmVBY3Rpb25GYWN0b3J5UmVzdWx0IH0gZnJvbSAnLi9jb2RlcGlwZWxpbmUtYWN0aW9uLWZhY3RvcnknO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVCdWlsZEZhY3RvcnlQcm9wcyB7XG4gIC8qKlxuICAgKiBOYW1lIGZvciB0aGUgZ2VuZXJhdGVkIENvZGVCdWlsZCBwcm9qZWN0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHByb2plY3ROYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDdXN0b21pemF0aW9uIG9wdGlvbnMgZm9yIHRoZSBwcm9qZWN0XG4gICAqXG4gICAqIFdpbGwgYXQgQ29kZUJ1aWxkIHByb2R1Y3Rpb24gdGltZSBiZSBjb21iaW5lZCB3aXRoIHRoZSBvcHRpb25cbiAgICogZGVmYXVsdHMgY29uZmlndXJlZCBvbiB0aGUgcGlwZWxpbmUuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gc3BlY2lhbCB2YWx1ZXNcbiAgICovXG4gIHJlYWRvbmx5IHByb2plY3RPcHRpb25zPzogQ29kZUJ1aWxkT3B0aW9ucztcblxuICAvKipcbiAgICogQ3VzdG9tIGV4ZWN1dGlvbiByb2xlIHRvIGJlIHVzZWQgZm9yIHRoZSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEEgcm9sZSBpcyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHJvbGU/OiBpYW0uSVJvbGU7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBidWlsZCBzcGVjIHdpbGwgYmUgcGFzc2VkIHZpYSB0aGUgQ2xvdWQgQXNzZW1ibHkgaW5zdGVhZCBvZiByZW5kZXJlZCBvbnRvIHRoZSBQcm9qZWN0XG4gICAqXG4gICAqIERvaW5nIHRoaXMgaGFzIHR3byBhZHZhbnRhZ2VzOlxuICAgKlxuICAgKiAtIEJ5cGFzcyBzaXplIHJlc3RyaWN0aW9uczogdGhlIGJ1aWxkc3BlYyBvbiB0aGUgcHJvamVjdCBpcyByZXN0cmljdGVkXG4gICAqICAgaW4gc2l6ZSwgd2hpbGUgYnVpbGRzcGVjcyBjb21pbmcgZnJvbSBhbiBpbnB1dCBhcnRpZmFjdCBhcmUgbm90IHJlc3RyaWN0ZWRcbiAgICogICBpbiBzdWNoIGEgd2F5LlxuICAgKiAtIEJ5cGFzcyBwaXBlbGluZSB1cGRhdGU6IGlmIHRoZSBTZWxmVXBkYXRlIHN0ZXAgaGFzIHRvIGNoYW5nZSB0aGUgYnVpbGRzcGVjLFxuICAgKiAgIHRoYXQganVzdCB0YWtlcyB0aW1lLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIGJ1aWxkc3BlYyBjb21lcyBmcm9tIHRoZVxuICAgKiAgIHBpcGVsaW5lIGFydGlmYWN0LCBubyBzdWNoIHVwZGF0ZSBoYXMgdG8gdGFrZSBwbGFjZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHBhc3NCdWlsZFNwZWNWaWFDbG91ZEFzc2VtYmx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGNvbnN0cnVjdCB0cmVlIHdoZXJlIHRoZSBDb2RlQnVpbGQgcHJvamVjdCBpcyBjcmVhdGVkLlxuICAgKlxuICAgKiBOb3JtYWxseSwgdGhlIGNvbnN0cnVjdCB0cmVlIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gICAqXG4gICAqICDilIDilIAgUGlwZWxpbmVcbiAgICogICAgICDilJTilIDilIAgJ015U3RhZ2UnICAgICAgICAgPC0gb3B0aW9ucy5zY29wZVxuICAgKiAgICAgICAgICAg4pSU4pSA4pSAICdNeUFjdGlvbicgICA8LSB0aGlzIGlzIHRoZSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBJZiB0aGlzIGZsYWcgaXMgc2V0LCB0aGUgY29uc3RydWN0IHRyZWUgd2lsbCBsb29rIGxpa2UgdGhpczpcbiAgICpcbiAgICogIOKUgOKUgCBQaXBlbGluZVxuICAgKiAgICAgIOKUlOKUgOKUgCAnTXlTdGFnZScgICAgICAgICAgICAgICAgICAgICAgICAgPC0gb3B0aW9ucy5zY29wZVxuICAgKiAgICAgICAgICAg4pSU4pSA4pSAICdNeUFjdGlvbicgICAgICAgICAgICAgICAgICAgPC0ganVzdCBhIHNjb3BlXG4gICAqICAgICAgICAgICAgICAgICAg4pSU4pSA4pSAICdCYWNrd2FyZHNDb21wYXROYW1lJyA8LSBDb2RlQnVpbGQgcHJvamVjdFxuICAgKlxuICAgKiBUaGlzIGlzIHRvIG1haW50YWluIGxvZ2ljYWxJRCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHByZXZpb3VzIGl0ZXJhdGlvblxuICAgKiBvZiBwaXBlbGluZXMgKHdoZXJlIHRoZSBBY3Rpb24gd2FzIGEgY29uc3RydWN0IHRoYXQgd291bGQgY3JlYXRlIHRoZSBQcm9qZWN0KS5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgYWRkaXRpb25hbENvbnN0cnVjdExldmVsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQWRkaXRpb25hbCBkZXBlbmRlbmN5IHRoYXQgdGhlIENvZGVCdWlsZCBwcm9qZWN0IHNob3VsZCB0YWtlXG4gICAqXG4gICAqIEBkZWZhdWx0IC1cbiAgICovXG4gIHJlYWRvbmx5IGFkZGl0aW9uYWxEZXBlbmRhYmxlPzogSURlcGVuZGFibGU7XG5cbiAgcmVhZG9ubHkgaW5wdXRzPzogRmlsZVNldExvY2F0aW9uW107XG4gIHJlYWRvbmx5IG91dHB1dHM/OiBGaWxlU2V0TG9jYXRpb25bXTtcblxuICByZWFkb25seSBzdGVwSWQ/OiBzdHJpbmc7XG5cbiAgcmVhZG9ubHkgY29tbWFuZHM6IHN0cmluZ1tdO1xuICByZWFkb25seSBpbnN0YWxsQ29tbWFuZHM/OiBzdHJpbmdbXTtcblxuICByZWFkb25seSBlbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBlbnZGcm9tQ2ZuT3V0cHV0cz86IFJlY29yZDxzdHJpbmcsIFN0YWNrT3V0cHV0UmVmZXJlbmNlPjtcblxuICAvKipcbiAgICogSWYgZ2l2ZW4sIG92ZXJyaWRlIHRoZSBzY29wZSBmcm9tIHRoZSBwcm9kdWNlIGNhbGwgd2l0aCB0aGlzIHNjb3BlLlxuICAgKi9cbiAgcmVhZG9ubHkgc2NvcGU/OiBDb25zdHJ1Y3Q7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBDb2RlQnVpbGQgcHJvamVjdCBpcyBnb2luZyB0byBiZSB0aGUgc3ludGggc3RlcFxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgaXNTeW50aD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIENvZGVCdWlsZCBwcm9qZWN0IGZyb20gYSBTaGVsbFN0ZXAgYW5kIHNvbWUgQ29kZUJ1aWxkLXNwZWNpZmljIGN1c3RvbWl6YXRpb25zXG4gKlxuICogVGhlIGZ1bmN0aW9uYWxpdHkgaGVyZSBpcyBzaGFyZWQgYmV0d2VlbiB0aGUgYENvZGVQaXBlbGluZWAgdHJhbnNsYXRpbmcgYSBgU2hlbGxTdGVwYCBpbnRvXG4gKiBhIENvZGVCdWlsZCBwcm9qZWN0LCBhcyB3ZWxsIGFzIHRoZSBgQ29kZUJ1aWxkU3RlcGAgc3RyYWlnaHQgdXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlQnVpbGRGYWN0b3J5IGltcGxlbWVudHMgSUNvZGVQaXBlbGluZUFjdGlvbkZhY3Rvcnkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBwdWJsaWMgc3RhdGljIGZyb21TaGVsbFN0ZXAoY29uc3RydWN0SWQ6IHN0cmluZywgc2hlbGxTdGVwOiBTaGVsbFN0ZXAsIGFkZGl0aW9uYWw/OiBQYXJ0aWFsPENvZGVCdWlsZEZhY3RvcnlQcm9wcz4pOiBJQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlQnVpbGRGYWN0b3J5KGNvbnN0cnVjdElkLCB7XG4gICAgICBjb21tYW5kczogc2hlbGxTdGVwLmNvbW1hbmRzLFxuICAgICAgZW52OiBzaGVsbFN0ZXAuZW52LFxuICAgICAgZW52RnJvbUNmbk91dHB1dHM6IHNoZWxsU3RlcC5lbnZGcm9tQ2ZuT3V0cHV0cyxcbiAgICAgIGlucHV0czogc2hlbGxTdGVwLmlucHV0cyxcbiAgICAgIG91dHB1dHM6IHNoZWxsU3RlcC5vdXRwdXRzLFxuICAgICAgc3RlcElkOiBzaGVsbFN0ZXAuaWQsXG4gICAgICBpbnN0YWxsQ29tbWFuZHM6IHNoZWxsU3RlcC5pbnN0YWxsQ29tbWFuZHMsXG4gICAgICAuLi5hZGRpdGlvbmFsLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tQ29kZUJ1aWxkU3RlcChjb25zdHJ1Y3RJZDogc3RyaW5nLCBzdGVwOiBDb2RlQnVpbGRTdGVwLCBhZGRpdGlvbmFsPzogUGFydGlhbDxDb2RlQnVpbGRGYWN0b3J5UHJvcHM+KTogSUNvZGVQaXBlbGluZUFjdGlvbkZhY3Rvcnkge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBDb2RlQnVpbGRGYWN0b3J5LmZyb21TaGVsbFN0ZXAoY29uc3RydWN0SWQsIHN0ZXAsIHtcbiAgICAgIHByb2plY3ROYW1lOiBzdGVwLnByb2plY3ROYW1lLFxuICAgICAgcm9sZTogc3RlcC5yb2xlLFxuICAgICAgcHJvamVjdE9wdGlvbnM6IHtcbiAgICAgICAgYnVpbGRFbnZpcm9ubWVudDogc3RlcC5idWlsZEVudmlyb25tZW50LFxuICAgICAgICByb2xlUG9saWN5OiBzdGVwLnJvbGVQb2xpY3lTdGF0ZW1lbnRzLFxuICAgICAgICBzZWN1cml0eUdyb3Vwczogc3RlcC5zZWN1cml0eUdyb3VwcyxcbiAgICAgICAgcGFydGlhbEJ1aWxkU3BlYzogc3RlcC5wYXJ0aWFsQnVpbGRTcGVjLFxuICAgICAgICB2cGM6IHN0ZXAudnBjLFxuICAgICAgICBzdWJuZXRTZWxlY3Rpb246IHN0ZXAuc3VibmV0U2VsZWN0aW9uLFxuICAgICAgICAuLi5hZGRpdGlvbmFsPy5wcm9qZWN0T3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICAuLi5hZGRpdGlvbmFsLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2R1Y2VBY3Rpb246IChzdGFnZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmYWN0b3J5LnByb2R1Y2VBY3Rpb24oc3RhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0LnByb2plY3QpIHtcbiAgICAgICAgICBzdGVwLl9zZXRQcm9qZWN0KHJlc3VsdC5wcm9qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfcHJvamVjdD86IGNvZGVidWlsZC5JUHJvamVjdDtcbiAgcHJpdmF0ZSBzdGVwSWQ6IHN0cmluZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uc3RydWN0SWQ6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHByb3BzOiBDb2RlQnVpbGRGYWN0b3J5UHJvcHMpIHtcblxuICAgIHRoaXMuc3RlcElkID0gcHJvcHMuc3RlcElkID8/IGNvbnN0cnVjdElkO1xuICB9XG5cbiAgcHVibGljIGdldCBwcm9qZWN0KCk6IGNvZGVidWlsZC5JUHJvamVjdCB7XG4gICAgaWYgKCF0aGlzLl9wcm9qZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgYmVjb21lcyBhdmFpbGFibGUgYWZ0ZXIgcHJvZHVjZSgpIGhhcyBiZWVuIGNhbGxlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdDtcbiAgfVxuXG4gIHB1YmxpYyBwcm9kdWNlQWN0aW9uKHN0YWdlOiBjb2RlcGlwZWxpbmUuSVN0YWdlLCBvcHRpb25zOiBQcm9kdWNlQWN0aW9uT3B0aW9ucyk6IENvZGVQaXBlbGluZUFjdGlvbkZhY3RvcnlSZXN1bHQge1xuICAgIGNvbnN0IHByb2plY3RPcHRpb25zID0gbWVyZ2VDb2RlQnVpbGRPcHRpb25zKG9wdGlvbnMuY29kZUJ1aWxkRGVmYXVsdHMsIHRoaXMucHJvcHMucHJvamVjdE9wdGlvbnMpO1xuXG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5wcm9wcy5pbnB1dHMgPz8gW107XG4gICAgY29uc3Qgb3V0cHV0cyA9IHRoaXMucHJvcHMub3V0cHV0cyA/PyBbXTtcblxuICAgIGNvbnN0IG1haW5JbnB1dCA9IGlucHV0cy5maW5kKHggPT4geC5kaXJlY3RvcnkgPT09ICcuJyk7XG4gICAgY29uc3QgZXh0cmFJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKHggPT4geC5kaXJlY3RvcnkgIT09ICcuJyk7XG5cbiAgICBjb25zdCBpbnB1dEFydGlmYWN0ID0gbWFpbklucHV0XG4gICAgICA/IG9wdGlvbnMuYXJ0aWZhY3RzLnRvQ29kZVBpcGVsaW5lKG1haW5JbnB1dC5maWxlU2V0KVxuICAgICAgOiBvcHRpb25zLmZhbGxiYWNrQXJ0aWZhY3Q7XG4gICAgY29uc3QgZXh0cmFJbnB1dEFydGlmYWN0cyA9IGV4dHJhSW5wdXRzLm1hcCh4ID0+IG9wdGlvbnMuYXJ0aWZhY3RzLnRvQ29kZVBpcGVsaW5lKHguZmlsZVNldCkpO1xuICAgIGNvbnN0IG91dHB1dEFydGlmYWN0cyA9IG91dHB1dHMubWFwKHggPT4gb3B0aW9ucy5hcnRpZmFjdHMudG9Db2RlUGlwZWxpbmUoeC5maWxlU2V0KSk7XG5cbiAgICBpZiAoIWlucHV0QXJ0aWZhY3QpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGFjdHVhbGx5IG5ldmVyIGhhcHBlbiBiZWNhdXNlIENvZGVCdWlsZCBwcm9qZWN0cyBzaG91bGRuJ3QgYmUgYWRkZWQgYmVmb3JlIHRoZVxuICAgICAgLy8gU291cmNlLCB3aGljaCBhbHdheXMgcHJvZHVjZXMgYXQgbGVhc3QgYW4gYXJ0aWZhY3QuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVCdWlsZCBhY3Rpb24gJyR7dGhpcy5zdGVwSWR9JyByZXF1aXJlcyBhbiBpbnB1dCAoYW5kIHRoZSBwaXBlbGluZSBkb2Vzbid0IGhhdmUgYSBTb3VyY2UgdG8gZmFsbCBiYWNrIHRvKS4gQWRkIGFuIGlucHV0IG9yIGEgcGlwZWxpbmUgc291cmNlLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbGxDb21tYW5kcyA9IFtcbiAgICAgIC4uLmdlbmVyYXRlSW5wdXRBcnRpZmFjdExpbmtDb21tYW5kcyhvcHRpb25zLmFydGlmYWN0cywgZXh0cmFJbnB1dHMpLFxuICAgICAgLi4udGhpcy5wcm9wcy5pbnN0YWxsQ29tbWFuZHMgPz8gW10sXG4gICAgXTtcblxuICAgIGNvbnN0IGJ1aWxkU3BlY0hlcmUgPSBjb2RlYnVpbGQuQnVpbGRTcGVjLmZyb21PYmplY3Qoe1xuICAgICAgdmVyc2lvbjogJzAuMicsXG4gICAgICBwaGFzZXM6IHtcbiAgICAgICAgaW5zdGFsbDogKGluc3RhbGxDb21tYW5kcy5sZW5ndGggPz8gMCkgPiAwID8geyBjb21tYW5kczogaW5zdGFsbENvbW1hbmRzIH0gOiB1bmRlZmluZWQsXG4gICAgICAgIGJ1aWxkOiB0aGlzLnByb3BzLmNvbW1hbmRzLmxlbmd0aCA+IDAgPyB7IGNvbW1hbmRzOiB0aGlzLnByb3BzLmNvbW1hbmRzIH0gOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgICAgYXJ0aWZhY3RzOiBub0VtcHR5T2JqZWN0PGFueT4ocmVuZGVyQXJ0aWZhY3RzQnVpbGRTcGVjKG9wdGlvbnMuYXJ0aWZhY3RzLCB0aGlzLnByb3BzLm91dHB1dHMgPz8gW10pKSxcbiAgICB9KTtcblxuICAgIC8vIFBhcnRpdGlvbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW50byBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBjYW4gZ28gb24gdGhlIHByb2plY3RcbiAgICAvLyBhbmQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgTVVTVCBnbyBpbiB0aGUgcGlwZWxpbmUgKHRob3NlIHRoYXQgcmVmZXJlbmNlIENvZGVQaXBlbGluZSB2YXJpYWJsZXMpXG4gICAgY29uc3QgZW52ID0gbm9VbmRlZmluZWQodGhpcy5wcm9wcy5lbnYgPz8ge30pO1xuXG4gICAgY29uc3QgW2FjdGlvbkVudnMsIHByb2plY3RFbnZzXSA9IHBhcnRpdGlvbihPYmplY3QuZW50cmllcyhlbnYgPz8ge30pLCAoWywgdl0pID0+IGNvbnRhaW5zUGlwZWxpbmVWYXJpYWJsZSh2KSk7XG5cbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoXG4gICAgICBwcm9qZWN0T3B0aW9ucz8uYnVpbGRFbnZpcm9ubWVudCA/PyB7fSxcbiAgICAgIHtcbiAgICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IG5vRW1wdHlPYmplY3QobWFwVmFsdWVzKG1rZGljdChwcm9qZWN0RW52cyksIHZhbHVlID0+ICh7IHZhbHVlIH0pKSksXG4gICAgICB9KTtcblxuICAgIGNvbnN0IGZ1bGxCdWlsZFNwZWMgPSBwcm9qZWN0T3B0aW9ucz8ucGFydGlhbEJ1aWxkU3BlY1xuICAgICAgPyBjb2RlYnVpbGQubWVyZ2VCdWlsZFNwZWNzKHByb2plY3RPcHRpb25zLnBhcnRpYWxCdWlsZFNwZWMsIGJ1aWxkU3BlY0hlcmUpXG4gICAgICA6IGJ1aWxkU3BlY0hlcmU7XG5cbiAgICBjb25zdCBvc0Zyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LmJ1aWxkSW1hZ2UgJiYgZW52aXJvbm1lbnQuYnVpbGRJbWFnZSBpbnN0YW5jZW9mIGNvZGVidWlsZC5XaW5kb3dzQnVpbGRJbWFnZVxuICAgICAgPyBlYzIuT3BlcmF0aW5nU3lzdGVtVHlwZS5XSU5ET1dTXG4gICAgICA6IGVjMi5PcGVyYXRpbmdTeXN0ZW1UeXBlLkxJTlVYO1xuXG4gICAgY29uc3QgYWN0dWFsQnVpbGRTcGVjID0gZmlsdGVyQnVpbGRTcGVjQ29tbWFuZHMoZnVsbEJ1aWxkU3BlYywgb3NGcm9tRW52aXJvbm1lbnQpO1xuXG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnByb3BzLnNjb3BlID8/IG9wdGlvbnMuc2NvcGU7XG5cbiAgICBsZXQgcHJvamVjdEJ1aWxkU3BlYztcbiAgICBpZiAodGhpcy5wcm9wcy5wYXNzQnVpbGRTcGVjVmlhQ2xvdWRBc3NlbWJseSkge1xuICAgICAgLy8gV3JpdGUgdG8gZGlzayBhbmQgcmVwbGFjZSB3aXRoIGEgcmVmZXJlbmNlXG4gICAgICBjb25zdCByZWxhdGl2ZVNwZWNGaWxlID0gYGJ1aWxkc3BlYy0ke05vZGUub2Yoc2NvcGUpLmFkZHJ9LSR7dGhpcy5jb25zdHJ1Y3RJZH0ueWFtbGA7XG4gICAgICBjb25zdCBhYnNTcGVjRmlsZSA9IHBhdGguam9pbihjbG91ZEFzc2VtYmx5QnVpbGRTcGVjRGlyKHNjb3BlKSwgcmVsYXRpdmVTcGVjRmlsZSk7XG5cbiAgICAgIC8vIFRoaXMgc2hvdWxkIHJlc29sdmUgdG8gYSBwdXJlIEpTT04gc3RyaW5nLiBJZiBpdCByZXNvbHZlcyB0byBhbiBvYmplY3QsIGl0J3MgYSBDRk5cbiAgICAgIC8vIGV4cHJlc3Npb24sIGFuZCB3ZSBjYW4ndCBzdXBwb3J0IHRoYXQgeWV0LiBNYXliZSBzb21lZGF5IGlmIHdlIHRoaW5rIHJlYWxseSBoYXJkIGFib3V0IGl0LlxuICAgICAgY29uc3QgZmlsZUNvbnRlbnRzID0gU3RhY2sub2Yoc2NvcGUpLnJlc29sdmUoYWN0dWFsQnVpbGRTcGVjLnRvQnVpbGRTcGVjKCkpO1xuXG4gICAgICBpZiAodHlwZW9mIGZpbGVDb250ZW50cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIEJ1aWxkU3BlYyBjb250YWlucyBDbG91ZEZvcm1hdGlvbiByZWZlcmVuY2VzIGFuZCBpcyBzdXBwb3J0ZWQgYnkgcHVibGlzaEluUGFyYWxsZWw9ZmFsc2U6ICR7SlNPTi5zdHJpbmdpZnkoZmlsZUNvbnRlbnRzLCB1bmRlZmluZWQsIDIpfWApO1xuICAgICAgfVxuICAgICAgZnMud3JpdGVGaWxlU3luYyhhYnNTcGVjRmlsZSwgZmlsZUNvbnRlbnRzLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgICAgcHJvamVjdEJ1aWxkU3BlYyA9IGNvZGVidWlsZC5CdWlsZFNwZWMuZnJvbVNvdXJjZUZpbGVuYW1lKHJlbGF0aXZlU3BlY0ZpbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9qZWN0QnVpbGRTcGVjID0gYWN0dWFsQnVpbGRTcGVjO1xuICAgIH1cblxuICAgIC8vIEEgaGFzaCBvdmVyIHRoZSB2YWx1ZXMgdGhhdCBtYWtlIHRoZSBDb2RlQnVpbGQgUHJvamVjdCB1bmlxdWUgKGFuZCBuZWNlc3NhcnlcbiAgICAvLyB0byByZXN0YXJ0IHRoZSBwaXBlbGluZSBpZiBvbmUgb2YgdGhlbSBjaGFuZ2VzKS4gcHJvamVjdE5hbWUgaXMgbm90IG5lY2Vzc2FyeSB0byBpbmNsdWRlXG4gICAgLy8gaGVyZSBiZWNhdXNlIHRoZSBwaXBlbGluZSB3aWxsIGRlZmluaXRlbHkgcmVzdGFydCBpZiBwcm9qZWN0TmFtZSBjaGFuZ2VzLlxuICAgIC8vIChSZXNvbHZlIHRva2VucylcbiAgICBjb25zdCBwcm9qZWN0Q29uZmlnSGFzaCA9IGhhc2goU3RhY2sub2Yoc2NvcGUpLnJlc29sdmUoe1xuICAgICAgZW52aXJvbm1lbnQ6IHNlcmlhbGl6ZUJ1aWxkRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpLFxuICAgICAgYnVpbGRTcGVjU3RyaW5nOiBhY3R1YWxCdWlsZFNwZWMudG9CdWlsZFNwZWMoKSxcbiAgICB9KSk7XG5cbiAgICBjb25zdCBhY3Rpb25OYW1lID0gb3B0aW9ucy5hY3Rpb25OYW1lID8/IHRoaXMuc3RlcElkO1xuXG4gICAgbGV0IHByb2plY3RTY29wZSA9IHNjb3BlO1xuICAgIGlmICh0aGlzLnByb3BzLmFkZGl0aW9uYWxDb25zdHJ1Y3RMZXZlbCA/PyB0cnVlKSB7XG4gICAgICBwcm9qZWN0U2NvcGUgPSBvYnRhaW5TY29wZShzY29wZSwgYWN0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvamVjdCA9IG5ldyBjb2RlYnVpbGQuUGlwZWxpbmVQcm9qZWN0KHByb2plY3RTY29wZSwgdGhpcy5jb25zdHJ1Y3RJZCwge1xuICAgICAgcHJvamVjdE5hbWU6IHRoaXMucHJvcHMucHJvamVjdE5hbWUsXG4gICAgICBlbnZpcm9ubWVudCxcbiAgICAgIHZwYzogcHJvamVjdE9wdGlvbnMudnBjLFxuICAgICAgc3VibmV0U2VsZWN0aW9uOiBwcm9qZWN0T3B0aW9ucy5zdWJuZXRTZWxlY3Rpb24sXG4gICAgICBzZWN1cml0eUdyb3VwczogcHJvamVjdE9wdGlvbnMuc2VjdXJpdHlHcm91cHMsXG4gICAgICBidWlsZFNwZWM6IHByb2plY3RCdWlsZFNwZWMsXG4gICAgICByb2xlOiB0aGlzLnByb3BzLnJvbGUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hZGRpdGlvbmFsRGVwZW5kYWJsZSkge1xuICAgICAgcHJvamVjdC5ub2RlLmFkZERlcGVuZGVuY3kodGhpcy5wcm9wcy5hZGRpdGlvbmFsRGVwZW5kYWJsZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2plY3RPcHRpb25zLnJvbGVQb2xpY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvamVjdE9wdGlvbnMucm9sZVBvbGljeS5mb3JFYWNoKHBvbGljeVN0YXRlbWVudCA9PiB7XG4gICAgICAgIHByb2plY3QuYWRkVG9Sb2xlUG9saWN5KHBvbGljeVN0YXRlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyaWVzID0gbmV3IFBpcGVsaW5lUXVlcmllcyhvcHRpb25zLnBpcGVsaW5lKTtcblxuICAgIGNvbnN0IHN0YWNrT3V0cHV0RW52ID0gbWFwVmFsdWVzKHRoaXMucHJvcHMuZW52RnJvbUNmbk91dHB1dHMgPz8ge30sIG91dHB1dFJlZiA9PlxuICAgICAgYCN7JHtzdGFja1ZhcmlhYmxlTmFtZXNwYWNlKHF1ZXJpZXMucHJvZHVjaW5nU3RhY2sob3V0cHV0UmVmKSl9LiR7b3V0cHV0UmVmLm91dHB1dE5hbWV9fWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGNvbmZpZ0hhc2hFbnYgPSBvcHRpb25zLmJlZm9yZVNlbGZNdXRhdGlvblxuICAgICAgPyB7IF9QUk9KRUNUX0NPTkZJR19IQVNIOiBwcm9qZWN0Q29uZmlnSGFzaCB9XG4gICAgICA6IHt9O1xuXG4gICAgc3RhZ2UuYWRkQWN0aW9uKG5ldyBjb2RlcGlwZWxpbmVfYWN0aW9ucy5Db2RlQnVpbGRBY3Rpb24oe1xuICAgICAgYWN0aW9uTmFtZTogYWN0aW9uTmFtZSxcbiAgICAgIGlucHV0OiBpbnB1dEFydGlmYWN0LFxuICAgICAgZXh0cmFJbnB1dHM6IGV4dHJhSW5wdXRBcnRpZmFjdHMsXG4gICAgICBvdXRwdXRzOiBvdXRwdXRBcnRpZmFjdHMsXG4gICAgICBwcm9qZWN0LFxuICAgICAgcnVuT3JkZXI6IG9wdGlvbnMucnVuT3JkZXIsXG5cbiAgICAgIC8vIEluY2x1c2lvbiBvZiB0aGUgaGFzaCBoZXJlIHdpbGwgbGVhZCB0byB0aGUgcGlwZWxpbmUgc3RydWN0dXJlIGZvciBhbnkgY2hhbmdlc1xuICAgICAgLy8gbWFkZSB0aGUgY29uZmlnIG9mIHRoZSB1bmRlcmx5aW5nIENvZGVCdWlsZCBQcm9qZWN0LlxuICAgICAgLy8gSGVuY2UsIHRoZSBwaXBlbGluZSB3aWxsIGJlIHJlc3RhcnRlZC4gVGhpcyBpcyBuZWNlc3NhcnkgaWYgdGhlIHVzZXJzXG4gICAgICAvLyBhZGRzIChmb3IgZXhhbXBsZSkgYnVpbGQgb3IgdGVzdCBjb21tYW5kcyB0byB0aGUgYnVpbGRzcGVjLlxuICAgICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IG5vRW1wdHlPYmplY3QoY2JFbnYoe1xuICAgICAgICAuLi5ta2RpY3QoYWN0aW9uRW52cyksXG4gICAgICAgIC4uLmNvbmZpZ0hhc2hFbnYsXG4gICAgICAgIC4uLnN0YWNrT3V0cHV0RW52LFxuICAgICAgfSkpLFxuICAgIH0pKTtcblxuICAgIHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXG4gICAgcmV0dXJuIHsgcnVuT3JkZXJzQ29uc3VtZWQ6IDEsIHByb2plY3QgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGNvbW1hbmRzIHRvIG1vdmUgYWRkaXRpb25hbCBpbnB1dCBhcnRpZmFjdHMgaW50byB0aGUgcmlnaHQgcGxhY2VcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJbnB1dEFydGlmYWN0TGlua0NvbW1hbmRzKGFydGlmYWN0czogQXJ0aWZhY3RNYXAsIGlucHV0czogRmlsZVNldExvY2F0aW9uW10pOiBzdHJpbmdbXSB7XG4gIHJldHVybiBpbnB1dHMubWFwKGlucHV0ID0+IHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBbXTtcblxuICAgIGlmICghWycuJywgJy4uJ10uaW5jbHVkZXMocGF0aC5kaXJuYW1lKGlucHV0LmRpcmVjdG9yeSkpKSB7XG4gICAgICBmcmFnbWVudHMucHVzaChgbWtkaXIgLXAgLS0gXCIke2lucHV0LmRpcmVjdG9yeX1cImApO1xuICAgIH1cblxuICAgIGNvbnN0IGFydGlmYWN0ID0gYXJ0aWZhY3RzLnRvQ29kZVBpcGVsaW5lKGlucHV0LmZpbGVTZXQpO1xuXG4gICAgZnJhZ21lbnRzLnB1c2goYGxuIC1zIC0tIFwiJENPREVCVUlMRF9TUkNfRElSXyR7YXJ0aWZhY3QuYXJ0aWZhY3ROYW1lfVwiIFwiJHtpbnB1dC5kaXJlY3Rvcnl9XCJgKTtcblxuICAgIHJldHVybiBmcmFnbWVudHMuam9pbignICYmICcpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyQXJ0aWZhY3RzQnVpbGRTcGVjKGFydGlmYWN0TWFwOiBBcnRpZmFjdE1hcCwgb3V0cHV0czogRmlsZVNldExvY2F0aW9uW10pIHtcbiAgLy8gc2F2ZSB0aGUgZ2VuZXJhdGVkIGZpbGVzIGluIHRoZSBvdXRwdXQgYXJ0aWZhY3RcbiAgLy8gVGhpcyBwYXJ0IG9mIHRoZSBidWlsZHNwZWMgaGFzIHRvIGxvb2sgY29tcGxldGVseSBkaWZmZXJlbnQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmVcbiAgLy8gdXNpbmcgc2Vjb25kYXJ5IGFydGlmYWN0cyBvciBub3QuXG4gIGlmIChvdXRwdXRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4ge307IH1cblxuICBpZiAob3V0cHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2Jhc2UtZGlyZWN0b3J5Jzogb3V0cHV0c1swXS5kaXJlY3RvcnksXG4gICAgICAnZmlsZXMnOiAnKiovKicsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHNlY29uZGFyeTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICBmb3IgKGNvbnN0IG91dHB1dCBvZiBvdXRwdXRzKSB7XG4gICAgY29uc3QgYXJ0ID0gYXJ0aWZhY3RNYXAudG9Db2RlUGlwZWxpbmUob3V0cHV0LmZpbGVTZXQpO1xuXG4gICAgaWYgKCFhcnQuYXJ0aWZhY3ROYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGdpdmUgdGhlIG91dHB1dCBhcnRpZmFjdCBhIG5hbWUnKTtcbiAgICB9XG4gICAgc2Vjb25kYXJ5W2FydC5hcnRpZmFjdE5hbWVdID0ge1xuICAgICAgJ2Jhc2UtZGlyZWN0b3J5Jzogb3V0cHV0LmRpcmVjdG9yeSxcbiAgICAgICdmaWxlcyc6ICcqKi8qJyxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHsgJ3NlY29uZGFyeS1hcnRpZmFjdHMnOiBzZWNvbmRhcnkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ29kZUJ1aWxkT3B0aW9ucyguLi5vcHRzOiBBcnJheTxDb2RlQnVpbGRPcHRpb25zIHwgdW5kZWZpbmVkPikge1xuICBjb25zdCB4cyA9IFt7fSwgLi4ub3B0cy5maWx0ZXIoaXNEZWZpbmVkKV07XG4gIHdoaWxlICh4cy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgW2EsIGJdID0geHMuc3BsaWNlKHhzLmxlbmd0aCAtIDIsIDIpO1xuICAgIHhzLnB1c2gobWVyZ2UyKGEsIGIpKTtcbiAgfVxuICByZXR1cm4geHNbMF07XG5cbiAgZnVuY3Rpb24gbWVyZ2UyKGE6IENvZGVCdWlsZE9wdGlvbnMsIGI6IENvZGVCdWlsZE9wdGlvbnMpOiBDb2RlQnVpbGRPcHRpb25zIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnVpbGRFbnZpcm9ubWVudDogbWVyZ2VCdWlsZEVudmlyb25tZW50cyhhLmJ1aWxkRW52aXJvbm1lbnQsIGIuYnVpbGRFbnZpcm9ubWVudCksXG4gICAgICByb2xlUG9saWN5OiBkZWZpbmVkQXJyYXkoWy4uLmEucm9sZVBvbGljeSA/PyBbXSwgLi4uYi5yb2xlUG9saWN5ID8/IFtdXSksXG4gICAgICBzZWN1cml0eUdyb3VwczogZGVmaW5lZEFycmF5KFsuLi5hLnNlY3VyaXR5R3JvdXBzID8/IFtdLCAuLi5iLnNlY3VyaXR5R3JvdXBzID8/IFtdXSksXG4gICAgICBwYXJ0aWFsQnVpbGRTcGVjOiBtZXJnZUJ1aWxkU3BlY3MoYS5wYXJ0aWFsQnVpbGRTcGVjLCBiLnBhcnRpYWxCdWlsZFNwZWMpLFxuICAgICAgdnBjOiBiLnZwYyA/PyBhLnZwYyxcbiAgICAgIHN1Ym5ldFNlbGVjdGlvbjogYi5zdWJuZXRTZWxlY3Rpb24gPz8gYS5zdWJuZXRTZWxlY3Rpb24sXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUJ1aWxkRW52aXJvbm1lbnRzKGE6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50LCBiPzogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQpOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudDtcbmZ1bmN0aW9uIG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoYTogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQgfCB1bmRlZmluZWQsIGI6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50KTogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQ7XG5mdW5jdGlvbiBtZXJnZUJ1aWxkRW52aXJvbm1lbnRzKGE/OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCwgYj86IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50KTogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQgfCB1bmRlZmluZWQ7XG5mdW5jdGlvbiBtZXJnZUJ1aWxkRW52aXJvbm1lbnRzKGE/OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCwgYj86IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50KSB7XG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA/PyBiOyB9XG5cbiAgcmV0dXJuIHtcbiAgICBidWlsZEltYWdlOiBiLmJ1aWxkSW1hZ2UgPz8gYS5idWlsZEltYWdlLFxuICAgIGNvbXB1dGVUeXBlOiBiLmNvbXB1dGVUeXBlID8/IGEuY29tcHV0ZVR5cGUsXG4gICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IHtcbiAgICAgIC4uLmEuZW52aXJvbm1lbnRWYXJpYWJsZXMsXG4gICAgICAuLi5iLmVudmlyb25tZW50VmFyaWFibGVzLFxuICAgIH0sXG4gICAgcHJpdmlsZWdlZDogYi5wcml2aWxlZ2VkID8/IGEucHJpdmlsZWdlZCxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnVpbGRTcGVjcyhhOiBjb2RlYnVpbGQuQnVpbGRTcGVjLCBiPzogY29kZWJ1aWxkLkJ1aWxkU3BlYyk6IGNvZGVidWlsZC5CdWlsZFNwZWM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VCdWlsZFNwZWNzKGE6IGNvZGVidWlsZC5CdWlsZFNwZWMgfCB1bmRlZmluZWQsIGI6IGNvZGVidWlsZC5CdWlsZFNwZWMpOiBjb2RlYnVpbGQuQnVpbGRTcGVjO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnVpbGRTcGVjcyhhPzogY29kZWJ1aWxkLkJ1aWxkU3BlYywgYj86IGNvZGVidWlsZC5CdWlsZFNwZWMpOiBjb2RlYnVpbGQuQnVpbGRTcGVjIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnVpbGRTcGVjcyhhPzogY29kZWJ1aWxkLkJ1aWxkU3BlYywgYj86IGNvZGVidWlsZC5CdWlsZFNwZWMpIHtcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID8/IGI7IH1cbiAgcmV0dXJuIGNvZGVidWlsZC5tZXJnZUJ1aWxkU3BlY3MoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5lZDxBPih4OiBBIHwgdW5kZWZpbmVkKTogeCBpcyBOb25OdWxsYWJsZTxBPiB7XG4gIHJldHVybiB4ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc2g8QT4ob2JqOiBBKSB7XG4gIGNvbnN0IGQgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gIGQudXBkYXRlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICByZXR1cm4gZC5kaWdlc3QoJ2hleCcpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIGJ1aWxkIGVudmlyb25tZW50IHRvIGRhdGEgKGdldCByaWQgb2YgY29uc3RydWN0cyAmIG9iamVjdHMpLCBzbyB3ZSBjYW4gSlNPTi5zdHJpbmdpZnkgaXRcbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQnVpbGRFbnZpcm9ubWVudChlbnY6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50KSB7XG4gIHJldHVybiB7XG4gICAgcHJpdmlsZWdlZDogZW52LnByaXZpbGVnZWQsXG4gICAgZW52aXJvbm1lbnRWYXJpYWJsZXM6IGVudi5lbnZpcm9ubWVudFZhcmlhYmxlcyxcbiAgICB0eXBlOiBlbnYuYnVpbGRJbWFnZT8udHlwZSxcbiAgICBpbWFnZUlkOiBlbnYuYnVpbGRJbWFnZT8uaW1hZ2VJZCxcbiAgICBjb21wdXRlVHlwZTogZW52LmNvbXB1dGVUeXBlLFxuICAgIGltYWdlUHVsbFByaW5jaXBhbFR5cGU6IGVudi5idWlsZEltYWdlPy5pbWFnZVB1bGxQcmluY2lwYWxUeXBlLFxuICAgIHNlY3JldHNNYW5hZ2VyQXJuOiBlbnYuYnVpbGRJbWFnZT8uc2VjcmV0c01hbmFnZXJDcmVkZW50aWFscz8uc2VjcmV0QXJuLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhY2tWYXJpYWJsZU5hbWVzcGFjZShzdGFjazogU3RhY2tEZXBsb3ltZW50KSB7XG4gIHJldHVybiBzdGFjay5zdGFja0FydGlmYWN0SWQ7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGEgQ29kZVBpcGVsaW5lIHZhcmlhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zUGlwZWxpbmVWYXJpYWJsZShzOiBzdHJpbmcpIHtcbiAgcmV0dXJuICEhcy5tYXRjaCgvI1xce1tefV0rXFx9Lyk7XG59XG5cbi8qKlxuICogVHVybiBhIGNvbGxlY3Rpb24gaW50byBhIGNvbGxlY3Rpb24gb2YgQ29kZVBpcGVsaW5lIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICovXG5mdW5jdGlvbiBjYkVudih4czogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPik6IFJlY29yZDxzdHJpbmcsIGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50VmFyaWFibGU+IHtcbiAgcmV0dXJuIG1rZGljdChPYmplY3QuZW50cmllcyh4cylcbiAgICAuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKVxuICAgIC5tYXAoKFtrLCB2XSkgPT4gW2ssIHsgdmFsdWU6IHYgfV0gYXMgY29uc3QpKTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lZEFycmF5PEE+KHhzOiBBW10pOiBBW10gfCB1bmRlZmluZWQge1xuICByZXR1cm4geHMubGVuZ3RoID4gMCA/IHhzIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIElmIGxpbmVzIGluIHRoZSBidWlsZHNwZWMgc3RhcnQgd2l0aCAnIVdJTkRPV1MhJyBvciAnIUxJTlVYIScsIG9ubHkgcmVuZGVyIHRoZW0gb24gdGhhdCBwbGF0Zm9ybS5cbiAqXG4gKiBWZXJ5IHByaXZhdGUgcHJvdG9jb2wgZm9yIG5vdywgYnV0IG1heSBjb21lIGluIGhhbmR5IGluIG90aGVyIGxpYnJhcmllcyBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBmaWx0ZXJCdWlsZFNwZWNDb21tYW5kcyhidWlsZFNwZWM6IGNvZGVidWlsZC5CdWlsZFNwZWMsIG9zVHlwZTogZWMyLk9wZXJhdGluZ1N5c3RlbVR5cGUpIHtcbiAgaWYgKCFidWlsZFNwZWMuaXNJbW1lZGlhdGUpIHsgcmV0dXJuIGJ1aWxkU3BlYzsgfVxuICBjb25zdCBzcGVjID0gKGJ1aWxkU3BlYyBhcyBhbnkpLnNwZWM7XG5cbiAgY29uc3Qgd2luVGFnID0gJyFXSU5ET1dTISc7XG4gIGNvbnN0IGxpbnV4VGFnID0gJyFMSU5VWCEnO1xuICBjb25zdCBleHBlY3RlZFRhZyA9IG9zVHlwZSA9PT0gZWMyLk9wZXJhdGluZ1N5c3RlbVR5cGUuV0lORE9XUyA/IHdpblRhZyA6IGxpbnV4VGFnO1xuXG4gIHJldHVybiBjb2RlYnVpbGQuQnVpbGRTcGVjLmZyb21PYmplY3QocmVjdXJzZShzcGVjKSk7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZSh4OiBhbnkpOiBhbnkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICBjb25zdCByZXQ6IGFueVtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVsIG9mIHgpIHtcbiAgICAgICAgY29uc3QgW3RhZywgcGF5bG9hZF0gPSBleHRyYWN0VGFnKGVsKTtcbiAgICAgICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyA9PT0gZXhwZWN0ZWRUYWcpIHtcbiAgICAgICAgICByZXQucHVzaChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbWFwVmFsdWVzKHgsIHJlY3Vyc2UpO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RUYWcoeDogYW55KTogW3N0cmluZyB8IHVuZGVmaW5lZCwgYW55XSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnc3RyaW5nJykgeyByZXR1cm4gW3VuZGVmaW5lZCwgeF07IH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBbd2luVGFnLCBsaW51eFRhZ10pIHtcbiAgICAgIGlmICh4LnN0YXJ0c1dpdGgodGFnKSkgeyByZXR1cm4gW3RhZywgeC5zdWJzdHIodGFnLmxlbmd0aCldOyB9XG4gICAgfVxuICAgIHJldHVybiBbdW5kZWZpbmVkLCB4XTtcbiAgfVxufSJdfQ==